(window["webpackJsonp_node_http_server"] = window["webpackJsonp_node_http_server"] || []).push([["vendor~.._node_modules_@wordpress_block-editor_b"],{

/***/ "/FOO":
/*!***************************************************************************!*\
  !*** ../node_modules/@wordpress/block-editor/build-module/utils/index.js ***!
  \***************************************************************************/
/*! exports provided: transformStyles, validateThemeColors, validateThemeGradients, __experimentalGetMatchingVariation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transform_styles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transform-styles */ "Co8E");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transformStyles", function() { return _transform_styles__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./theme */ "cUWY");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "validateThemeColors", function() { return _theme__WEBPACK_IMPORTED_MODULE_1__["validateThemeColors"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "validateThemeGradients", function() { return _theme__WEBPACK_IMPORTED_MODULE_1__["validateThemeGradients"]; });

/* harmony import */ var _block_variation_transforms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./block-variation-transforms */ "x28A");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "__experimentalGetMatchingVariation", function() { return _block_variation_transforms__WEBPACK_IMPORTED_MODULE_2__["__experimentalGetMatchingVariation"]; });




//# sourceMappingURL=index.js.map

/***/ }),

/***/ "0O9v":
/*!******************************************************************************!*\
  !*** ../node_modules/@wordpress/block-editor/build-module/store/defaults.js ***!
  \******************************************************************************/
/*! exports provided: PREFERENCES_DEFAULTS, SETTINGS_DEFAULTS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PREFERENCES_DEFAULTS", function() { return PREFERENCES_DEFAULTS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SETTINGS_DEFAULTS", function() { return SETTINGS_DEFAULTS; });
/* harmony import */ var _wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wordpress/i18n */ "yAFj");
/**
 * WordPress dependencies
 */

const PREFERENCES_DEFAULTS = {
  insertUsage: {}
};
/**
 * The default editor settings
 *
 * @typedef {Object} SETTINGS_DEFAULT
 * @property {boolean} alignWide Enable/Disable Wide/Full Alignments
 * @property {boolean} supportsLayout Enable/disable layouts support in container blocks.
 * @property {boolean} imageEditing Image Editing settings set to false to disable.
 * @property {Array} imageSizes Available image sizes
 * @property {number} maxWidth Max width to constraint resizing
 * @property {boolean|Array} allowedBlockTypes Allowed block types
 * @property {boolean} hasFixedToolbar Whether or not the editor toolbar is fixed
 * @property {boolean} focusMode Whether the focus mode is enabled or not
 * @property {Array} styles Editor Styles
 * @property {boolean} keepCaretInsideBlock Whether caret should move between blocks in edit mode
 * @property {string} bodyPlaceholder Empty post placeholder
 * @property {string} titlePlaceholder Empty title placeholder
 * @property {boolean} codeEditingEnabled Whether or not the user can switch to the code editor
 * @property {boolean} __experimentalCanUserUseUnfilteredHTML Whether the user should be able to use unfiltered HTML or the HTML should be filtered e.g., to remove elements considered insecure like iframes.
 * @property {boolean} __experimentalBlockDirectory Whether the user has enabled the Block Directory
 * @property {Array} __experimentalBlockPatterns Array of objects representing the block patterns
 * @property {Array} __experimentalBlockPatternCategories Array of objects representing the block pattern categories
 */

const SETTINGS_DEFAULTS = {
  alignWide: false,
  supportsLayout: true,
  // colors setting is not used anymore now defaults are passed from theme.json on the server and core has its own defaults.
  // The setting is only kept for backward compatibility purposes.
  colors: [{
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Black'),
    slug: 'black',
    color: '#000000'
  }, {
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Cyan bluish gray'),
    slug: 'cyan-bluish-gray',
    color: '#abb8c3'
  }, {
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('White'),
    slug: 'white',
    color: '#ffffff'
  }, {
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Pale pink'),
    slug: 'pale-pink',
    color: '#f78da7'
  }, {
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Vivid red'),
    slug: 'vivid-red',
    color: '#cf2e2e'
  }, {
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Luminous vivid orange'),
    slug: 'luminous-vivid-orange',
    color: '#ff6900'
  }, {
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Luminous vivid amber'),
    slug: 'luminous-vivid-amber',
    color: '#fcb900'
  }, {
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Light green cyan'),
    slug: 'light-green-cyan',
    color: '#7bdcb5'
  }, {
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Vivid green cyan'),
    slug: 'vivid-green-cyan',
    color: '#00d084'
  }, {
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Pale cyan blue'),
    slug: 'pale-cyan-blue',
    color: '#8ed1fc'
  }, {
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Vivid cyan blue'),
    slug: 'vivid-cyan-blue',
    color: '#0693e3'
  }, {
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Vivid purple'),
    slug: 'vivid-purple',
    color: '#9b51e0'
  }],
  // fontSizes setting is not used anymore now defaults are passed from theme.json on the server and core has its own defaults.
  // The setting is only kept for backward compatibility purposes.
  fontSizes: [{
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["_x"])('Small', 'font size name'),
    size: 13,
    slug: 'small'
  }, {
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["_x"])('Normal', 'font size name'),
    size: 16,
    slug: 'normal'
  }, {
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["_x"])('Medium', 'font size name'),
    size: 20,
    slug: 'medium'
  }, {
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["_x"])('Large', 'font size name'),
    size: 36,
    slug: 'large'
  }, {
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["_x"])('Huge', 'font size name'),
    size: 42,
    slug: 'huge'
  }],
  // Image default size slug.
  imageDefaultSize: 'large',
  imageSizes: [{
    slug: 'thumbnail',
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Thumbnail')
  }, {
    slug: 'medium',
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Medium')
  }, {
    slug: 'large',
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Large')
  }, {
    slug: 'full',
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Full Size')
  }],
  // Allow plugin to disable Image Editor if need be
  imageEditing: true,
  // This is current max width of the block inner area
  // It's used to constraint image resizing and this value could be overridden later by themes
  maxWidth: 580,
  // Allowed block types for the editor, defaulting to true (all supported).
  allowedBlockTypes: true,
  // Maximum upload size in bytes allowed for the site.
  maxUploadFileSize: 0,
  // List of allowed mime types and file extensions.
  allowedMimeTypes: null,
  __experimentalCanUserUseUnfilteredHTML: false,
  __experimentalBlockDirectory: false,
  __mobileEnablePageTemplates: false,
  __experimentalBlockPatterns: [],
  __experimentalBlockPatternCategories: [],
  __experimentalSpotlightEntityBlocks: [],
  // gradients setting is not used anymore now defaults are passed from theme.json on the server and core has its own defaults.
  // The setting is only kept for backward compatibility purposes.
  gradients: [{
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Vivid cyan blue to vivid purple'),
    gradient: 'linear-gradient(135deg,rgba(6,147,227,1) 0%,rgb(155,81,224) 100%)',
    slug: 'vivid-cyan-blue-to-vivid-purple'
  }, {
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Light green cyan to vivid green cyan'),
    gradient: 'linear-gradient(135deg,rgb(122,220,180) 0%,rgb(0,208,130) 100%)',
    slug: 'light-green-cyan-to-vivid-green-cyan'
  }, {
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Luminous vivid amber to luminous vivid orange'),
    gradient: 'linear-gradient(135deg,rgba(252,185,0,1) 0%,rgba(255,105,0,1) 100%)',
    slug: 'luminous-vivid-amber-to-luminous-vivid-orange'
  }, {
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Luminous vivid orange to vivid red'),
    gradient: 'linear-gradient(135deg,rgba(255,105,0,1) 0%,rgb(207,46,46) 100%)',
    slug: 'luminous-vivid-orange-to-vivid-red'
  }, {
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Very light gray to cyan bluish gray'),
    gradient: 'linear-gradient(135deg,rgb(238,238,238) 0%,rgb(169,184,195) 100%)',
    slug: 'very-light-gray-to-cyan-bluish-gray'
  }, {
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Cool to warm spectrum'),
    gradient: 'linear-gradient(135deg,rgb(74,234,220) 0%,rgb(151,120,209) 20%,rgb(207,42,186) 40%,rgb(238,44,130) 60%,rgb(251,105,98) 80%,rgb(254,248,76) 100%)',
    slug: 'cool-to-warm-spectrum'
  }, {
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Blush light purple'),
    gradient: 'linear-gradient(135deg,rgb(255,206,236) 0%,rgb(152,150,240) 100%)',
    slug: 'blush-light-purple'
  }, {
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Blush bordeaux'),
    gradient: 'linear-gradient(135deg,rgb(254,205,165) 0%,rgb(254,45,45) 50%,rgb(107,0,62) 100%)',
    slug: 'blush-bordeaux'
  }, {
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Luminous dusk'),
    gradient: 'linear-gradient(135deg,rgb(255,203,112) 0%,rgb(199,81,192) 50%,rgb(65,88,208) 100%)',
    slug: 'luminous-dusk'
  }, {
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Pale ocean'),
    gradient: 'linear-gradient(135deg,rgb(255,245,203) 0%,rgb(182,227,212) 50%,rgb(51,167,181) 100%)',
    slug: 'pale-ocean'
  }, {
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Electric grass'),
    gradient: 'linear-gradient(135deg,rgb(202,248,128) 0%,rgb(113,206,126) 100%)',
    slug: 'electric-grass'
  }, {
    name: Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__["__"])('Midnight'),
    gradient: 'linear-gradient(135deg,rgb(2,3,129) 0%,rgb(40,116,252) 100%)',
    slug: 'midnight'
  }]
};
//# sourceMappingURL=defaults.js.map

/***/ }),

/***/ "4jdN":
/*!******************************************************************************************************!*\
  !*** ../node_modules/@wordpress/block-editor/build-module/utils/transform-styles/transforms/wrap.js ***!
  \******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @constant string IS_ROOT_TAG Regex to check if the selector is a root tag selector.
 */
const IS_ROOT_TAG = /^(body|html|:root).*$/;

const wrap = (namespace, ignore = []) => node => {
  const updateSelector = selector => {
    if (ignore.includes(selector.trim())) {
      return selector;
    } // Anything other than a root tag is always prefixed.


    {
      if (!selector.match(IS_ROOT_TAG)) {
        return namespace + ' ' + selector;
      }
    } // HTML and Body elements cannot be contained within our container so lets extract their styles.

    return selector.replace(/^(body|html|:root)/, namespace);
  };

  if (node.type === 'rule') {
    return { ...node,
      selectors: node.selectors.map(updateSelector)
    };
  }

  return node;
};

/* harmony default export */ __webpack_exports__["default"] = (wrap);
//# sourceMappingURL=wrap.js.map

/***/ }),

/***/ "9Kek":
/*!*************************************************************************!*\
  !*** ../node_modules/@wordpress/block-editor/build-module/utils/dom.js ***!
  \*************************************************************************/
/*! exports provided: isInSameBlock, isInsideRootBlock, getBlockClientId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isInSameBlock", function() { return isInSameBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isInsideRootBlock", function() { return isInsideRootBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBlockClientId", function() { return getBlockClientId; });
const BLOCK_SELECTOR = '.block-editor-block-list__block';
/**
 * Returns true if two elements are contained within the same block.
 *
 * @param {Element} a First element.
 * @param {Element} b Second element.
 *
 * @return {boolean} Whether elements are in the same block.
 */

function isInSameBlock(a, b) {
  return a.closest(BLOCK_SELECTOR) === b.closest(BLOCK_SELECTOR);
}
/**
 * Returns true if an element is considered part of the block and not its
 * children.
 *
 * @param {Element} blockElement Block container element.
 * @param {Element} element      Element.
 *
 * @return {boolean} Whether element is in the block Element but not its
 *                   children.
 */

function isInsideRootBlock(blockElement, element) {
  const parentBlock = element.closest(BLOCK_SELECTOR);
  return parentBlock === blockElement;
}
/**
 * Finds the block client ID given any DOM node inside the block.
 *
 * @param {Node?} node DOM node.
 *
 * @return {string|undefined} Client ID or undefined if the node is not part of
 *                            a block.
 */

function getBlockClientId(node) {
  while (node && node.nodeType !== node.ELEMENT_NODE) {
    node = node.parentNode;
  }

  if (!node) {
    return;
  }

  const elementNode =
  /** @type {Element} */
  node;
  const blockNode = elementNode.closest(BLOCK_SELECTOR);

  if (!blockNode) {
    return;
  }

  return blockNode.id.slice('block-'.length);
}
//# sourceMappingURL=dom.js.map

/***/ }),

/***/ "9sXs":
/*!**************************************************************************!*\
  !*** ../node_modules/@wordpress/block-editor/build-module/utils/math.js ***!
  \**************************************************************************/
/*! exports provided: getDistanceFromPointToEdge, getDistanceToNearestEdge */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDistanceFromPointToEdge", function() { return getDistanceFromPointToEdge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDistanceToNearestEdge", function() { return getDistanceToNearestEdge; });
/**
 * A string representing the name of an edge.
 *
 * @typedef {'top'|'right'|'bottom'|'left'} WPEdgeName
 */

/**
 * @typedef  {Object} WPPoint
 * @property {number} x The horizontal position.
 * @property {number} y The vertical position.
 */

/**
 * Given a point, a DOMRect and the name of an edge, returns the distance to
 * that edge of the rect.
 *
 * This function works for edges that are horizontal or vertical (e.g. not
 * rotated), the following terms are used so that the function works in both
 * orientations:
 *
 * - Forward, meaning the axis running horizontally when an edge is vertical
 *   and vertically when an edge is horizontal.
 * - Lateral, meaning the axis running vertically when an edge is vertical
 *   and horizontally when an edge is horizontal.
 *
 * @param {WPPoint}    point The point to measure distance from.
 * @param {DOMRect}    rect  A DOM Rect containing edge positions.
 * @param {WPEdgeName} edge  The edge to measure to.
 */
function getDistanceFromPointToEdge(point, rect, edge) {
  const isHorizontal = edge === 'top' || edge === 'bottom';
  const {
    x,
    y
  } = point;
  const pointLateralPosition = isHorizontal ? x : y;
  const pointForwardPosition = isHorizontal ? y : x;
  const edgeStart = isHorizontal ? rect.left : rect.top;
  const edgeEnd = isHorizontal ? rect.right : rect.bottom;
  const edgeForwardPosition = rect[edge]; // Measure the straight line distance to the edge of the rect, when the
  // point is adjacent to the edge.
  // Else, if the point is positioned diagonally to the edge of the rect,
  // measure diagonally to the nearest corner that the edge meets.

  let edgeLateralPosition;

  if (pointLateralPosition >= edgeStart && pointLateralPosition <= edgeEnd) {
    edgeLateralPosition = pointLateralPosition;
  } else if (pointLateralPosition < edgeEnd) {
    edgeLateralPosition = edgeStart;
  } else {
    edgeLateralPosition = edgeEnd;
  }

  return Math.sqrt((pointLateralPosition - edgeLateralPosition) ** 2 + (pointForwardPosition - edgeForwardPosition) ** 2);
}
/**
 * Given a point, a DOMRect and a list of allowed edges returns the name of and
 * distance to the nearest edge.
 *
 * @param {WPPoint}      point        The point to measure distance from.
 * @param {DOMRect}      rect         A DOM Rect containing edge positions.
 * @param {WPEdgeName[]} allowedEdges A list of the edges included in the
 *                                    calculation. Defaults to all edges.
 *
 * @return {[number, string]} An array where the first value is the distance
 *                              and a second is the edge name.
 */

function getDistanceToNearestEdge(point, rect, allowedEdges = ['top', 'bottom', 'left', 'right']) {
  let candidateDistance;
  let candidateEdge;
  allowedEdges.forEach(edge => {
    const distance = getDistanceFromPointToEdge(point, rect, edge);

    if (candidateDistance === undefined || distance < candidateDistance) {
      candidateDistance = distance;
      candidateEdge = edge;
    }
  });
  return [candidateDistance, candidateEdge];
}
//# sourceMappingURL=math.js.map

/***/ }),

/***/ "Co8E":
/*!********************************************************************************************!*\
  !*** ../node_modules/@wordpress/block-editor/build-module/utils/transform-styles/index.js ***!
  \********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "9va6");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_compose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wordpress/compose */ "gc3H");
/* harmony import */ var _traverse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./traverse */ "cQaR");
/* harmony import */ var _transforms_url_rewrite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transforms/url-rewrite */ "QYxo");
/* harmony import */ var _transforms_wrap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./transforms/wrap */ "4jdN");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */




/**
 * Applies a series of CSS rule transforms to wrap selectors inside a given class and/or rewrite URLs depending on the parameters passed.
 *
 * @param {Array} styles CSS rules.
 * @param {string} wrapperClassName Wrapper Class Name.
 * @return {Array} converted rules.
 */

const transformStyles = (styles, wrapperClassName = '') => {
  return Object(lodash__WEBPACK_IMPORTED_MODULE_0__["map"])(styles, ({
    css,
    baseURL,
    __experimentalNoWrapper = false
  }) => {
    const transforms = [];

    if (wrapperClassName && !__experimentalNoWrapper) {
      transforms.push(Object(_transforms_wrap__WEBPACK_IMPORTED_MODULE_4__["default"])(wrapperClassName));
    }

    if (baseURL) {
      transforms.push(Object(_transforms_url_rewrite__WEBPACK_IMPORTED_MODULE_3__["default"])(baseURL));
    }

    if (transforms.length) {
      return Object(_traverse__WEBPACK_IMPORTED_MODULE_2__["default"])(css, Object(_wordpress_compose__WEBPACK_IMPORTED_MODULE_1__["compose"])(transforms));
    }

    return css;
  });
};

/* harmony default export */ __webpack_exports__["default"] = (transformStyles);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "DdeO":
/*!*****************************************************************************!*\
  !*** ../node_modules/@wordpress/block-editor/build-module/store/reducer.js ***!
  \*****************************************************************************/
/*! exports provided: hasSameKeys, isUpdatingSameBlockAttribute, blocks, isTyping, draggedBlocks, isCaretWithinFormattedText, selection, isMultiSelecting, isSelectionEnabled, initialPosition, blocksMode, insertionPoint, template, settings, preferences, blockListSettings, isNavigationMode, hasBlockMovingClientId, lastBlockAttributesChange, automaticChangeStatus, highlightedBlock, lastBlockInserted, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasSameKeys", function() { return hasSameKeys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isUpdatingSameBlockAttribute", function() { return isUpdatingSameBlockAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "blocks", function() { return blocks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTyping", function() { return isTyping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "draggedBlocks", function() { return draggedBlocks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isCaretWithinFormattedText", function() { return isCaretWithinFormattedText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selection", function() { return selection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMultiSelecting", function() { return isMultiSelecting; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSelectionEnabled", function() { return isSelectionEnabled; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initialPosition", function() { return initialPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "blocksMode", function() { return blocksMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertionPoint", function() { return insertionPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "template", function() { return template; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "settings", function() { return settings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "preferences", function() { return preferences; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "blockListSettings", function() { return blockListSettings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNavigationMode", function() { return isNavigationMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasBlockMovingClientId", function() { return hasBlockMovingClientId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lastBlockAttributesChange", function() { return lastBlockAttributesChange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "automaticChangeStatus", function() { return automaticChangeStatus; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "highlightedBlock", function() { return highlightedBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lastBlockInserted", function() { return lastBlockInserted; });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "9va6");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wordpress/data */ "OgwO");
/* harmony import */ var _wordpress_blocks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @wordpress/blocks */ "f/Qs");
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./defaults */ "0O9v");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./array */ "sWxo");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */



/**
 * Internal dependencies
 */



/**
 * Given an array of blocks, returns an object where each key is a nesting
 * context, the value of which is an array of block client IDs existing within
 * that nesting context.
 *
 * @param {Array}   blocks       Blocks to map.
 * @param {?string} rootClientId Assumed root client ID.
 *
 * @return {Object} Block order map object.
 */

function mapBlockOrder(blocks, rootClientId = '') {
  const result = {
    [rootClientId]: []
  };
  blocks.forEach(block => {
    const {
      clientId,
      innerBlocks
    } = block;
    result[rootClientId].push(clientId);
    Object.assign(result, mapBlockOrder(innerBlocks, clientId));
  });
  return result;
}
/**
 * Given an array of blocks, returns an object where each key contains
 * the clientId of the block and the value is the parent of the block.
 *
 * @param {Array}   blocks       Blocks to map.
 * @param {?string} rootClientId Assumed root client ID.
 *
 * @return {Object} Block order map object.
 */


function mapBlockParents(blocks, rootClientId = '') {
  return blocks.reduce((result, block) => Object.assign(result, {
    [block.clientId]: rootClientId
  }, mapBlockParents(block.innerBlocks, block.clientId)), {});
}
/**
 * Helper method to iterate through all blocks, recursing into inner blocks,
 * applying a transformation function to each one.
 * Returns a flattened object with the transformed blocks.
 *
 * @param {Array} blocks Blocks to flatten.
 * @param {Function} transform Transforming function to be applied to each block.
 *
 * @return {Object} Flattened object.
 */


function flattenBlocks(blocks, transform = lodash__WEBPACK_IMPORTED_MODULE_0__["identity"]) {
  const result = {};
  const stack = [...blocks];

  while (stack.length) {
    const {
      innerBlocks,
      ...block
    } = stack.shift();
    stack.push(...innerBlocks);
    result[block.clientId] = transform(block);
  }

  return result;
}
/**
 * Given an array of blocks, returns an object containing all blocks, without
 * attributes, recursing into inner blocks. Keys correspond to the block client
 * ID, the value of which is the attributes object.
 *
 * @param {Array} blocks Blocks to flatten.
 *
 * @return {Object} Flattened block attributes object.
 */


function getFlattenedBlocksWithoutAttributes(blocks) {
  return flattenBlocks(blocks, block => Object(lodash__WEBPACK_IMPORTED_MODULE_0__["omit"])(block, 'attributes'));
}
/**
 * Given an array of blocks, returns an object containing all block attributes,
 * recursing into inner blocks. Keys correspond to the block client ID, the
 * value of which is the attributes object.
 *
 * @param {Array} blocks Blocks to flatten.
 *
 * @return {Object} Flattened block attributes object.
 */


function getFlattenedBlockAttributes(blocks) {
  return flattenBlocks(blocks, block => block.attributes);
}
/**
 * Given a block order map object, returns *all* of the block client IDs that are
 * a descendant of the given root client ID.
 *
 * Calling this with `rootClientId` set to `''` results in a list of client IDs
 * that are in the post. That is, it excludes blocks like fetched reusable
 * blocks which are stored into state but not visible. It also excludes
 * InnerBlocks controllers, like template parts.
 *
 * It is important to exclude the full inner block controller and not just the
 * inner blocks because in many cases, we need to persist the previous value of
 * an inner block controller. To do so, it must be excluded from the list of
 * client IDs which are considered to be part of the top-level entity.
 *
 * @param {Object}  blocksOrder  Object that maps block client IDs to a list of
 *                               nested block client IDs.
 * @param {?string} rootClientId The root client ID to search. Defaults to ''.
 * @param {?Object} controlledInnerBlocks The InnerBlocks controller state.
 *
 * @return {Array} List of descendant client IDs.
 */


function getNestedBlockClientIds(blocksOrder, rootClientId = '', controlledInnerBlocks = {}) {
  return Object(lodash__WEBPACK_IMPORTED_MODULE_0__["reduce"])(blocksOrder[rootClientId], (result, clientId) => {
    if (!!controlledInnerBlocks[clientId]) {
      return result;
    }

    return [...result, clientId, ...getNestedBlockClientIds(blocksOrder, clientId)];
  }, []);
}
/**
 * Returns an object against which it is safe to perform mutating operations,
 * given the original object and its current working copy.
 *
 * @param {Object} original Original object.
 * @param {Object} working  Working object.
 *
 * @return {Object} Mutation-safe object.
 */


function getMutateSafeObject(original, working) {
  if (original === working) {
    return { ...original
    };
  }

  return working;
}
/**
 * Returns true if the two object arguments have the same keys, or false
 * otherwise.
 *
 * @param {Object} a First object.
 * @param {Object} b Second object.
 *
 * @return {boolean} Whether the two objects have the same keys.
 */


function hasSameKeys(a, b) {
  return Object(lodash__WEBPACK_IMPORTED_MODULE_0__["isEqual"])(Object(lodash__WEBPACK_IMPORTED_MODULE_0__["keys"])(a), Object(lodash__WEBPACK_IMPORTED_MODULE_0__["keys"])(b));
}
/**
 * Returns true if, given the currently dispatching action and the previously
 * dispatched action, the two actions are updating the same block attribute, or
 * false otherwise.
 *
 * @param {Object} action     Currently dispatching action.
 * @param {Object} lastAction Previously dispatched action.
 *
 * @return {boolean} Whether actions are updating the same block attribute.
 */

function isUpdatingSameBlockAttribute(action, lastAction) {
  return action.type === 'UPDATE_BLOCK_ATTRIBUTES' && lastAction !== undefined && lastAction.type === 'UPDATE_BLOCK_ATTRIBUTES' && Object(lodash__WEBPACK_IMPORTED_MODULE_0__["isEqual"])(action.clientIds, lastAction.clientIds) && hasSameKeys(action.attributes, lastAction.attributes);
}
/**
 * Utility returning an object with an empty object value for each key.
 *
 * @param {Array} objectKeys Keys to fill.
 * @return {Object} Object filled with empty object as values for each clientId.
 */

const fillKeysWithEmptyObject = objectKeys => {
  return objectKeys.reduce((result, key) => {
    result[key] = {};
    return result;
  }, {});
};
/**
 * Higher-order reducer intended to compute a cache key for each block in the post.
 * A new instance of the cache key (empty object) is created each time the block object
 * needs to be refreshed (for any change in the block or its children).
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


const withBlockCache = reducer => (state = {}, action) => {
  const newState = reducer(state, action);

  if (newState === state) {
    return state;
  }

  newState.cache = state.cache ? state.cache : {};
  /**
   * For each clientId provided, traverses up parents, adding the provided clientIds
   * and each parent's clientId to the returned array.
   *
   * When calling this function consider that it uses the old state, so any state
   * modifications made by the `reducer` will not be present.
   *
   * @param {Array} clientIds an Array of block clientIds.
   *
   * @return {Array} The provided clientIds and all of their parent clientIds.
   */

  const getBlocksWithParentsClientIds = clientIds => {
    return clientIds.reduce((result, clientId) => {
      let current = clientId;

      do {
        result.push(current);
        current = state.parents[current];
      } while (current && !state.controlledInnerBlocks[current]);

      return result;
    }, []);
  };

  switch (action.type) {
    case 'RESET_BLOCKS':
      newState.cache = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["mapValues"])(flattenBlocks(action.blocks), () => ({}));
      break;

    case 'RECEIVE_BLOCKS':
    case 'INSERT_BLOCKS':
      {
        const updatedBlockUids = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["keys"])(flattenBlocks(action.blocks));

        if (action.rootClientId && !state.controlledInnerBlocks[action.rootClientId]) {
          updatedBlockUids.push(action.rootClientId);
        }

        newState.cache = { ...newState.cache,
          ...fillKeysWithEmptyObject(getBlocksWithParentsClientIds(updatedBlockUids))
        };
        break;
      }

    case 'UPDATE_BLOCK':
      newState.cache = { ...newState.cache,
        ...fillKeysWithEmptyObject(getBlocksWithParentsClientIds([action.clientId]))
      };
      break;

    case 'UPDATE_BLOCK_ATTRIBUTES':
      newState.cache = { ...newState.cache,
        ...fillKeysWithEmptyObject(getBlocksWithParentsClientIds(action.clientIds))
      };
      break;

    case 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN':
      const parentClientIds = fillKeysWithEmptyObject(getBlocksWithParentsClientIds(action.replacedClientIds));
      newState.cache = { ...Object(lodash__WEBPACK_IMPORTED_MODULE_0__["omit"])(newState.cache, action.replacedClientIds),
        ...Object(lodash__WEBPACK_IMPORTED_MODULE_0__["omit"])(parentClientIds, action.replacedClientIds),
        ...fillKeysWithEmptyObject(Object(lodash__WEBPACK_IMPORTED_MODULE_0__["keys"])(flattenBlocks(action.blocks)))
      };
      break;

    case 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN':
      newState.cache = { ...Object(lodash__WEBPACK_IMPORTED_MODULE_0__["omit"])(newState.cache, action.removedClientIds),
        ...fillKeysWithEmptyObject(Object(lodash__WEBPACK_IMPORTED_MODULE_0__["difference"])(getBlocksWithParentsClientIds(action.clientIds), action.clientIds))
      };
      break;

    case 'MOVE_BLOCKS_TO_POSITION':
      {
        const updatedBlockUids = [...action.clientIds];

        if (action.fromRootClientId) {
          updatedBlockUids.push(action.fromRootClientId);
        }

        if (action.toRootClientId) {
          updatedBlockUids.push(action.toRootClientId);
        }

        newState.cache = { ...newState.cache,
          ...fillKeysWithEmptyObject(getBlocksWithParentsClientIds(updatedBlockUids))
        };
        break;
      }

    case 'MOVE_BLOCKS_UP':
    case 'MOVE_BLOCKS_DOWN':
      {
        const updatedBlockUids = [];

        if (action.rootClientId) {
          updatedBlockUids.push(action.rootClientId);
        }

        newState.cache = { ...newState.cache,
          ...fillKeysWithEmptyObject(getBlocksWithParentsClientIds(updatedBlockUids))
        };
        break;
      }

    case 'SAVE_REUSABLE_BLOCK_SUCCESS':
      {
        const updatedBlockUids = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["keys"])(Object(lodash__WEBPACK_IMPORTED_MODULE_0__["omitBy"])(newState.attributes, (attributes, clientId) => {
          return newState.byClientId[clientId].name !== 'core/block' || attributes.ref !== action.updatedId;
        }));
        newState.cache = { ...newState.cache,
          ...fillKeysWithEmptyObject(getBlocksWithParentsClientIds(updatedBlockUids))
        };
      }
  }

  return newState;
};
/**
 * Higher-order reducer intended to augment the blocks reducer, assigning an
 * `isPersistentChange` property value corresponding to whether a change in
 * state can be considered as persistent. All changes are considered persistent
 * except when updating the same block attribute as in the previous action.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


function withPersistentBlockChange(reducer) {
  let lastAction;
  let markNextChangeAsNotPersistent = false;
  return (state, action) => {
    let nextState = reducer(state, action);
    const isExplicitPersistentChange = action.type === 'MARK_LAST_CHANGE_AS_PERSISTENT' || markNextChangeAsNotPersistent; // Defer to previous state value (or default) unless changing or
    // explicitly marking as persistent.

    if (state === nextState && !isExplicitPersistentChange) {
      var _state$isPersistentCh;

      markNextChangeAsNotPersistent = action.type === 'MARK_NEXT_CHANGE_AS_NOT_PERSISTENT';
      const nextIsPersistentChange = (_state$isPersistentCh = state === null || state === void 0 ? void 0 : state.isPersistentChange) !== null && _state$isPersistentCh !== void 0 ? _state$isPersistentCh : true;

      if (state.isPersistentChange === nextIsPersistentChange) {
        return state;
      }

      return { ...nextState,
        isPersistentChange: nextIsPersistentChange
      };
    }

    nextState = { ...nextState,
      isPersistentChange: isExplicitPersistentChange ? !markNextChangeAsNotPersistent : !isUpdatingSameBlockAttribute(action, lastAction)
    }; // In comparing against the previous action, consider only those which
    // would have qualified as one which would have been ignored or not
    // have resulted in a changed state.

    lastAction = action;
    markNextChangeAsNotPersistent = action.type === 'MARK_NEXT_CHANGE_AS_NOT_PERSISTENT';
    return nextState;
  };
}
/**
 * Higher-order reducer intended to augment the blocks reducer, assigning an
 * `isIgnoredChange` property value corresponding to whether a change in state
 * can be considered as ignored. A change is considered ignored when the result
 * of an action not incurred by direct user interaction.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


function withIgnoredBlockChange(reducer) {
  /**
   * Set of action types for which a blocks state change should be ignored.
   *
   * @type {Set}
   */
  const IGNORED_ACTION_TYPES = new Set(['RECEIVE_BLOCKS']);
  return (state, action) => {
    const nextState = reducer(state, action);

    if (nextState !== state) {
      nextState.isIgnoredChange = IGNORED_ACTION_TYPES.has(action.type);
    }

    return nextState;
  };
}
/**
 * Higher-order reducer targeting the combined blocks reducer, augmenting
 * block client IDs in remove action to include cascade of inner blocks.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


const withInnerBlocksRemoveCascade = reducer => (state, action) => {
  // Gets all children which need to be removed.
  const getAllChildren = clientIds => {
    let result = clientIds;

    for (let i = 0; i < result.length; i++) {
      if (!state.order[result[i]] || action.keepControlledInnerBlocks && action.keepControlledInnerBlocks[result[i]]) {
        continue;
      }

      if (result === clientIds) {
        result = [...result];
      }

      result.push(...state.order[result[i]]);
    }

    return result;
  };

  if (state) {
    switch (action.type) {
      case 'REMOVE_BLOCKS':
        action = { ...action,
          type: 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN',
          removedClientIds: getAllChildren(action.clientIds)
        };
        break;

      case 'REPLACE_BLOCKS':
        action = { ...action,
          type: 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN',
          replacedClientIds: getAllChildren(action.clientIds)
        };
        break;
    }
  }

  return reducer(state, action);
};
/**
 * Higher-order reducer which targets the combined blocks reducer and handles
 * the `RESET_BLOCKS` action. When dispatched, this action will replace all
 * blocks that exist in the post, leaving blocks that exist only in state (e.g.
 * reusable blocks and blocks controlled by inner blocks controllers) alone.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


const withBlockReset = reducer => (state, action) => {
  if (state && action.type === 'RESET_BLOCKS') {
    /**
     * A list of client IDs associated with the top level entity (like a
     * post or template). It excludes the client IDs of blocks associated
     * with other entities, like inner block controllers or reusable blocks.
     */
    const visibleClientIds = getNestedBlockClientIds(state.order, '', state.controlledInnerBlocks); // pickBy returns only the truthy values from controlledInnerBlocks

    const controlledInnerBlocks = Object.keys(Object(lodash__WEBPACK_IMPORTED_MODULE_0__["pickBy"])(state.controlledInnerBlocks));
    /**
     * Each update operation consists of a few parts:
     * 1. First, the client IDs associated with the top level entity are
     *    removed from the existing state key, leaving in place controlled
     *    blocks (like reusable blocks and inner block controllers).
     * 2. Second, the blocks from the reset action are used to calculate the
     *    individual state keys. This will re-populate the clientIDs which
     *    were removed in step 1.
     * 3. In some cases, we remove the recalculated inner block controllers,
     *    letting their old values persist. We need to do this because the
     *    reset block action from a top-level entity is not aware of any
     *    inner blocks inside InnerBlock controllers. So if the new values
     *    were used, it would not take into account the existing InnerBlocks
     *    which already exist in the state for inner block controllers. For
     *    example, `attributes` uses the newly computed value for controllers
     *    since attributes are stored in the top-level entity. But `order`
     *    uses the previous value for the controllers since the new value
     *    does not include the order of controlled inner blocks. So if the
     *    new value was used, template parts would disappear from the editor
     *    whenever you try to undo a change in the top level entity.
     */

    return { ...state,
      byClientId: { ...Object(lodash__WEBPACK_IMPORTED_MODULE_0__["omit"])(state.byClientId, visibleClientIds),
        ...getFlattenedBlocksWithoutAttributes(action.blocks)
      },
      attributes: { ...Object(lodash__WEBPACK_IMPORTED_MODULE_0__["omit"])(state.attributes, visibleClientIds),
        ...getFlattenedBlockAttributes(action.blocks)
      },
      order: { ...Object(lodash__WEBPACK_IMPORTED_MODULE_0__["omit"])(state.order, visibleClientIds),
        ...Object(lodash__WEBPACK_IMPORTED_MODULE_0__["omit"])(mapBlockOrder(action.blocks), controlledInnerBlocks)
      },
      parents: { ...Object(lodash__WEBPACK_IMPORTED_MODULE_0__["omit"])(state.parents, visibleClientIds),
        ...mapBlockParents(action.blocks)
      },
      cache: { ...Object(lodash__WEBPACK_IMPORTED_MODULE_0__["omit"])(state.cache, visibleClientIds),
        ...Object(lodash__WEBPACK_IMPORTED_MODULE_0__["omit"])(Object(lodash__WEBPACK_IMPORTED_MODULE_0__["mapValues"])(flattenBlocks(action.blocks), () => ({})), controlledInnerBlocks)
      }
    };
  }

  return reducer(state, action);
};
/**
 * Higher-order reducer which targets the combined blocks reducer and handles
 * the `REPLACE_INNER_BLOCKS` action. When dispatched, this action the state
 * should become equivalent to the execution of a `REMOVE_BLOCKS` action
 * containing all the child's of the root block followed by the execution of
 * `INSERT_BLOCKS` with the new blocks.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


const withReplaceInnerBlocks = reducer => (state, action) => {
  if (action.type !== 'REPLACE_INNER_BLOCKS') {
    return reducer(state, action);
  } // Finds every nested inner block controller. We must check the action blocks
  // and not just the block parent state because some inner block controllers
  // should be deleted if specified, whereas others should not be deleted. If
  // a controlled should not be deleted, then we need to avoid deleting its
  // inner blocks from the block state because its inner blocks will not be
  // attached to the block in the action.


  const nestedControllers = {};

  if (Object.keys(state.controlledInnerBlocks).length) {
    const stack = [...action.blocks];

    while (stack.length) {
      const {
        innerBlocks,
        ...block
      } = stack.shift();
      stack.push(...innerBlocks);

      if (!!state.controlledInnerBlocks[block.clientId]) {
        nestedControllers[block.clientId] = true;
      }
    }
  } // The `keepControlledInnerBlocks` prop will keep the inner blocks of the
  // marked block in the block state so that they can be reattached to the
  // marked block when we re-insert everything a few lines below.


  let stateAfterBlocksRemoval = state;

  if (state.order[action.rootClientId]) {
    stateAfterBlocksRemoval = reducer(stateAfterBlocksRemoval, {
      type: 'REMOVE_BLOCKS',
      keepControlledInnerBlocks: nestedControllers,
      clientIds: state.order[action.rootClientId]
    });
  }

  let stateAfterInsert = stateAfterBlocksRemoval;

  if (action.blocks.length) {
    stateAfterInsert = reducer(stateAfterInsert, { ...action,
      type: 'INSERT_BLOCKS',
      index: 0
    }); // We need to re-attach the block order of the controlled inner blocks.
    // Otherwise, an inner block controller's blocks will be deleted entirely
    // from its entity..

    stateAfterInsert.order = { ...stateAfterInsert.order,
      ...Object(lodash__WEBPACK_IMPORTED_MODULE_0__["reduce"])(nestedControllers, (result, value, key) => {
        if (state.order[key]) {
          result[key] = state.order[key];
        }

        return result;
      }, {})
    };
  }

  return stateAfterInsert;
};
/**
 * Higher-order reducer which targets the combined blocks reducer and handles
 * the `SAVE_REUSABLE_BLOCK_SUCCESS` action. This action can't be handled by
 * regular reducers and needs a higher-order reducer since it needs access to
 * both `byClientId` and `attributes` simultaneously.
 *
 * @param {Function} reducer Original reducer function.
 *
 * @return {Function} Enhanced reducer function.
 */


const withSaveReusableBlock = reducer => (state, action) => {
  if (state && action.type === 'SAVE_REUSABLE_BLOCK_SUCCESS') {
    const {
      id,
      updatedId
    } = action; // If a temporary reusable block is saved, we swap the temporary id with the final one

    if (id === updatedId) {
      return state;
    }

    state = { ...state
    };
    state.attributes = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["mapValues"])(state.attributes, (attributes, clientId) => {
      const {
        name
      } = state.byClientId[clientId];

      if (name === 'core/block' && attributes.ref === id) {
        return { ...attributes,
          ref: updatedId
        };
      }

      return attributes;
    });
  }

  return reducer(state, action);
};
/**
 * Reducer returning the blocks state.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */


const blocks = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["flow"])(_wordpress_data__WEBPACK_IMPORTED_MODULE_1__["combineReducers"], withSaveReusableBlock, // needs to be before withBlockCache
withBlockCache, // needs to be before withInnerBlocksRemoveCascade
withInnerBlocksRemoveCascade, withReplaceInnerBlocks, // needs to be after withInnerBlocksRemoveCascade
withBlockReset, withPersistentBlockChange, withIgnoredBlockChange)({
  byClientId(state = {}, action) {
    switch (action.type) {
      case 'RESET_BLOCKS':
        return getFlattenedBlocksWithoutAttributes(action.blocks);

      case 'RECEIVE_BLOCKS':
      case 'INSERT_BLOCKS':
        return { ...state,
          ...getFlattenedBlocksWithoutAttributes(action.blocks)
        };

      case 'UPDATE_BLOCK':
        // Ignore updates if block isn't known
        if (!state[action.clientId]) {
          return state;
        } // Do nothing if only attributes change.


        const changes = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["omit"])(action.updates, 'attributes');

        if (Object(lodash__WEBPACK_IMPORTED_MODULE_0__["isEmpty"])(changes)) {
          return state;
        }

        return { ...state,
          [action.clientId]: { ...state[action.clientId],
            ...changes
          }
        };

      case 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        if (!action.blocks) {
          return state;
        }

        return { ...Object(lodash__WEBPACK_IMPORTED_MODULE_0__["omit"])(state, action.replacedClientIds),
          ...getFlattenedBlocksWithoutAttributes(action.blocks)
        };

      case 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        return Object(lodash__WEBPACK_IMPORTED_MODULE_0__["omit"])(state, action.removedClientIds);
    }

    return state;
  },

  attributes(state = {}, action) {
    switch (action.type) {
      case 'RESET_BLOCKS':
        return getFlattenedBlockAttributes(action.blocks);

      case 'RECEIVE_BLOCKS':
      case 'INSERT_BLOCKS':
        return { ...state,
          ...getFlattenedBlockAttributes(action.blocks)
        };

      case 'UPDATE_BLOCK':
        // Ignore updates if block isn't known or there are no attribute changes.
        if (!state[action.clientId] || !action.updates.attributes) {
          return state;
        }

        return { ...state,
          [action.clientId]: { ...state[action.clientId],
            ...action.updates.attributes
          }
        };

      case 'UPDATE_BLOCK_ATTRIBUTES':
        {
          // Avoid a state change if none of the block IDs are known.
          if (action.clientIds.every(id => !state[id])) {
            return state;
          }

          const next = action.clientIds.reduce((accumulator, id) => ({ ...accumulator,
            [id]: Object(lodash__WEBPACK_IMPORTED_MODULE_0__["reduce"])(action.uniqueByBlock ? action.attributes[id] : action.attributes, (result, value, key) => {
              // Consider as updates only changed values.
              if (value !== result[key]) {
                result = getMutateSafeObject(state[id], result);
                result[key] = value;
              }

              return result;
            }, state[id])
          }), {});

          if (action.clientIds.every(id => next[id] === state[id])) {
            return state;
          }

          return { ...state,
            ...next
          };
        }

      case 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        if (!action.blocks) {
          return state;
        }

        return { ...Object(lodash__WEBPACK_IMPORTED_MODULE_0__["omit"])(state, action.replacedClientIds),
          ...getFlattenedBlockAttributes(action.blocks)
        };

      case 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        return Object(lodash__WEBPACK_IMPORTED_MODULE_0__["omit"])(state, action.removedClientIds);
    }

    return state;
  },

  order(state = {}, action) {
    switch (action.type) {
      case 'RESET_BLOCKS':
        return mapBlockOrder(action.blocks);

      case 'RECEIVE_BLOCKS':
        return { ...state,
          ...Object(lodash__WEBPACK_IMPORTED_MODULE_0__["omit"])(mapBlockOrder(action.blocks), '')
        };

      case 'INSERT_BLOCKS':
        {
          const {
            rootClientId = ''
          } = action;
          const subState = state[rootClientId] || [];
          const mappedBlocks = mapBlockOrder(action.blocks, rootClientId);
          const {
            index = subState.length
          } = action;
          return { ...state,
            ...mappedBlocks,
            [rootClientId]: Object(_array__WEBPACK_IMPORTED_MODULE_4__["insertAt"])(subState, mappedBlocks[rootClientId], index)
          };
        }

      case 'MOVE_BLOCKS_TO_POSITION':
        {
          const {
            fromRootClientId = '',
            toRootClientId = '',
            clientIds
          } = action;
          const {
            index = state[toRootClientId].length
          } = action; // Moving inside the same parent block

          if (fromRootClientId === toRootClientId) {
            const subState = state[toRootClientId];
            const fromIndex = subState.indexOf(clientIds[0]);
            return { ...state,
              [toRootClientId]: Object(_array__WEBPACK_IMPORTED_MODULE_4__["moveTo"])(state[toRootClientId], fromIndex, index, clientIds.length)
            };
          } // Moving from a parent block to another


          return { ...state,
            [fromRootClientId]: Object(lodash__WEBPACK_IMPORTED_MODULE_0__["without"])(state[fromRootClientId], ...clientIds),
            [toRootClientId]: Object(_array__WEBPACK_IMPORTED_MODULE_4__["insertAt"])(state[toRootClientId], clientIds, index)
          };
        }

      case 'MOVE_BLOCKS_UP':
        {
          const {
            clientIds,
            rootClientId = ''
          } = action;
          const firstClientId = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["first"])(clientIds);
          const subState = state[rootClientId];

          if (!subState.length || firstClientId === Object(lodash__WEBPACK_IMPORTED_MODULE_0__["first"])(subState)) {
            return state;
          }

          const firstIndex = subState.indexOf(firstClientId);
          return { ...state,
            [rootClientId]: Object(_array__WEBPACK_IMPORTED_MODULE_4__["moveTo"])(subState, firstIndex, firstIndex - 1, clientIds.length)
          };
        }

      case 'MOVE_BLOCKS_DOWN':
        {
          const {
            clientIds,
            rootClientId = ''
          } = action;
          const firstClientId = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["first"])(clientIds);
          const lastClientId = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["last"])(clientIds);
          const subState = state[rootClientId];

          if (!subState.length || lastClientId === Object(lodash__WEBPACK_IMPORTED_MODULE_0__["last"])(subState)) {
            return state;
          }

          const firstIndex = subState.indexOf(firstClientId);
          return { ...state,
            [rootClientId]: Object(_array__WEBPACK_IMPORTED_MODULE_4__["moveTo"])(subState, firstIndex, firstIndex + 1, clientIds.length)
          };
        }

      case 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        {
          const {
            clientIds
          } = action;

          if (!action.blocks) {
            return state;
          }

          const mappedBlocks = mapBlockOrder(action.blocks);
          return Object(lodash__WEBPACK_IMPORTED_MODULE_0__["flow"])([nextState => Object(lodash__WEBPACK_IMPORTED_MODULE_0__["omit"])(nextState, action.replacedClientIds), nextState => ({ ...nextState,
            ...Object(lodash__WEBPACK_IMPORTED_MODULE_0__["omit"])(mappedBlocks, '')
          }), nextState => Object(lodash__WEBPACK_IMPORTED_MODULE_0__["mapValues"])(nextState, subState => Object(lodash__WEBPACK_IMPORTED_MODULE_0__["reduce"])(subState, (result, clientId) => {
            if (clientId === clientIds[0]) {
              return [...result, ...mappedBlocks['']];
            }

            if (clientIds.indexOf(clientId) === -1) {
              result.push(clientId);
            }

            return result;
          }, []))])(state);
        }

      case 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        return Object(lodash__WEBPACK_IMPORTED_MODULE_0__["flow"])([// Remove inner block ordering for removed blocks
        nextState => Object(lodash__WEBPACK_IMPORTED_MODULE_0__["omit"])(nextState, action.removedClientIds), // Remove deleted blocks from other blocks' orderings
        nextState => Object(lodash__WEBPACK_IMPORTED_MODULE_0__["mapValues"])(nextState, subState => Object(lodash__WEBPACK_IMPORTED_MODULE_0__["without"])(subState, ...action.removedClientIds))])(state);
    }

    return state;
  },

  // While technically redundant data as the inverse of `order`, it serves as
  // an optimization for the selectors which derive the ancestry of a block.
  parents(state = {}, action) {
    switch (action.type) {
      case 'RESET_BLOCKS':
        return mapBlockParents(action.blocks);

      case 'RECEIVE_BLOCKS':
        return { ...state,
          ...mapBlockParents(action.blocks)
        };

      case 'INSERT_BLOCKS':
        return { ...state,
          ...mapBlockParents(action.blocks, action.rootClientId || '')
        };

      case 'MOVE_BLOCKS_TO_POSITION':
        {
          return { ...state,
            ...action.clientIds.reduce((accumulator, id) => {
              accumulator[id] = action.toRootClientId || '';
              return accumulator;
            }, {})
          };
        }

      case 'REPLACE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        return { ...Object(lodash__WEBPACK_IMPORTED_MODULE_0__["omit"])(state, action.replacedClientIds),
          ...mapBlockParents(action.blocks, state[action.clientIds[0]])
        };

      case 'REMOVE_BLOCKS_AUGMENTED_WITH_CHILDREN':
        return Object(lodash__WEBPACK_IMPORTED_MODULE_0__["omit"])(state, action.removedClientIds);
    }

    return state;
  },

  controlledInnerBlocks(state = {}, {
    type,
    clientId,
    hasControlledInnerBlocks
  }) {
    if (type === 'SET_HAS_CONTROLLED_INNER_BLOCKS') {
      return { ...state,
        [clientId]: hasControlledInnerBlocks
      };
    }

    return state;
  }

});
/**
 * Reducer returning typing state.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {boolean} Updated state.
 */

function isTyping(state = false, action) {
  switch (action.type) {
    case 'START_TYPING':
      return true;

    case 'STOP_TYPING':
      return false;
  }

  return state;
}
/**
 * Reducer returning dragged block client id.
 *
 * @param {string[]} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {string[]} Updated state.
 */

function draggedBlocks(state = [], action) {
  switch (action.type) {
    case 'START_DRAGGING_BLOCKS':
      return action.clientIds;

    case 'STOP_DRAGGING_BLOCKS':
      return [];
  }

  return state;
}
/**
 * Reducer returning whether the caret is within formatted text.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {boolean} Updated state.
 */

function isCaretWithinFormattedText(state = false, action) {
  switch (action.type) {
    case 'ENTER_FORMATTED_TEXT':
      return true;

    case 'EXIT_FORMATTED_TEXT':
      return false;
  }

  return state;
}
/**
 * Internal helper reducer for selectionStart and selectionEnd. Can hold a block
 * selection, represented by an object with property clientId.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */

function selectionHelper(state = {}, action) {
  switch (action.type) {
    case 'CLEAR_SELECTED_BLOCK':
      {
        if (state.clientId) {
          return {};
        }

        return state;
      }

    case 'SELECT_BLOCK':
      if (action.clientId === state.clientId) {
        return state;
      }

      return {
        clientId: action.clientId
      };

    case 'REPLACE_INNER_BLOCKS':
    case 'INSERT_BLOCKS':
      {
        if (!action.updateSelection || !action.blocks.length) {
          return state;
        }

        return {
          clientId: action.blocks[0].clientId
        };
      }

    case 'REMOVE_BLOCKS':
      if (!action.clientIds || !action.clientIds.length || action.clientIds.indexOf(state.clientId) === -1) {
        return state;
      }

      return {};

    case 'REPLACE_BLOCKS':
      {
        if (action.clientIds.indexOf(state.clientId) === -1) {
          return state;
        }

        const indexToSelect = action.indexToSelect || action.blocks.length - 1;
        const blockToSelect = action.blocks[indexToSelect];

        if (!blockToSelect) {
          return {};
        }

        if (blockToSelect.clientId === state.clientId) {
          return state;
        }

        return {
          clientId: blockToSelect.clientId
        };
      }
  }

  return state;
}
/**
 * Reducer returning the selection state.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {boolean} Updated state.
 */


function selection(state = {}, action) {
  var _state$selectionStart, _state$selectionEnd;

  switch (action.type) {
    case 'SELECTION_CHANGE':
      return {
        selectionStart: {
          clientId: action.clientId,
          attributeKey: action.attributeKey,
          offset: action.startOffset
        },
        selectionEnd: {
          clientId: action.clientId,
          attributeKey: action.attributeKey,
          offset: action.endOffset
        }
      };

    case 'RESET_SELECTION':
      const {
        selectionStart,
        selectionEnd
      } = action;
      return {
        selectionStart,
        selectionEnd
      };

    case 'MULTI_SELECT':
      const {
        start,
        end
      } = action;
      return {
        selectionStart: {
          clientId: start
        },
        selectionEnd: {
          clientId: end
        }
      };

    case 'RESET_BLOCKS':
      const startClientId = state === null || state === void 0 ? void 0 : (_state$selectionStart = state.selectionStart) === null || _state$selectionStart === void 0 ? void 0 : _state$selectionStart.clientId;
      const endClientId = state === null || state === void 0 ? void 0 : (_state$selectionEnd = state.selectionEnd) === null || _state$selectionEnd === void 0 ? void 0 : _state$selectionEnd.clientId; // Do nothing if there's no selected block.

      if (!startClientId && !endClientId) {
        return state;
      } // If the start of the selection won't exist after reset, remove selection.


      if (!action.blocks.some(block => block.clientId === startClientId)) {
        return {
          selectionStart: {},
          selectionEnd: {}
        };
      } // If the end of the selection won't exist after reset, collapse selection.


      if (!action.blocks.some(block => block.clientId === endClientId)) {
        return { ...state,
          selectionEnd: state.selectionStart
        };
      }

  }

  return {
    selectionStart: selectionHelper(state.selectionStart, action),
    selectionEnd: selectionHelper(state.selectionEnd, action)
  };
}
/**
 * Reducer returning whether the user is multi-selecting.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {boolean} Updated state.
 */

function isMultiSelecting(state = false, action) {
  switch (action.type) {
    case 'START_MULTI_SELECT':
      return true;

    case 'STOP_MULTI_SELECT':
      return false;
  }

  return state;
}
/**
 * Reducer returning whether selection is enabled.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {boolean} Updated state.
 */

function isSelectionEnabled(state = true, action) {
  switch (action.type) {
    case 'TOGGLE_SELECTION':
      return action.isSelectionEnabled;
  }

  return state;
}
/**
 * Reducer returning the intial block selection.
 *
 * Currently this in only used to restore the selection after block deletion and
 * pasting new content.This reducer should eventually be removed in favour of setting
 * selection directly.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {number|null} Initial position: 0, -1 or null.
 */

function initialPosition(state = null, action) {
  if (action.type === 'REPLACE_BLOCKS' && action.initialPosition !== undefined) {
    return action.initialPosition;
  } else if (['SELECT_BLOCK', 'RESET_SELECTION', 'INSERT_BLOCKS', 'REPLACE_INNER_BLOCKS'].includes(action.type)) {
    return action.initialPosition;
  }

  return state;
}
function blocksMode(state = {}, action) {
  if (action.type === 'TOGGLE_BLOCK_MODE') {
    const {
      clientId
    } = action;
    return { ...state,
      [clientId]: state[clientId] && state[clientId] === 'html' ? 'visual' : 'html'
    };
  }

  return state;
}
/**
 * Reducer returning the block insertion point visibility, either null if there
 * is not an explicit insertion point assigned, or an object of its `index` and
 * `rootClientId`.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */

function insertionPoint(state = null, action) {
  switch (action.type) {
    case 'SHOW_INSERTION_POINT':
      const {
        rootClientId,
        index,
        __unstableWithInserter
      } = action;
      return {
        rootClientId,
        index,
        __unstableWithInserter
      };

    case 'HIDE_INSERTION_POINT':
      return null;
  }

  return state;
}
/**
 * Reducer returning whether the post blocks match the defined template or not.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {boolean} Updated state.
 */

function template(state = {
  isValid: true
}, action) {
  switch (action.type) {
    case 'SET_TEMPLATE_VALIDITY':
      return { ...state,
        isValid: action.isValid
      };
  }

  return state;
}
/**
 * Reducer returning the editor setting.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */

function settings(state = _defaults__WEBPACK_IMPORTED_MODULE_3__["SETTINGS_DEFAULTS"], action) {
  switch (action.type) {
    case 'UPDATE_SETTINGS':
      return { ...state,
        ...action.settings
      };
  }

  return state;
}
/**
 * Reducer returning the user preferences.
 *
 * @param {Object}  state                 Current state.
 * @param {Object}  action                Dispatched action.
 *
 * @return {string} Updated state.
 */

function preferences(state = _defaults__WEBPACK_IMPORTED_MODULE_3__["PREFERENCES_DEFAULTS"], action) {
  switch (action.type) {
    case 'INSERT_BLOCKS':
    case 'REPLACE_BLOCKS':
      return action.blocks.reduce((prevState, block) => {
        const {
          attributes,
          name: blockName
        } = block;
        const match = Object(_wordpress_data__WEBPACK_IMPORTED_MODULE_1__["select"])(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_2__["store"]).getActiveBlockVariation(blockName, attributes); // If a block variation match is found change the name to be the same with the
        // one that is used for block variations in the Inserter (`getItemFromVariation`).

        let id = match !== null && match !== void 0 && match.name ? `${blockName}/${match.name}` : blockName;
        const insert = {
          name: id
        };

        if (blockName === 'core/block') {
          insert.ref = attributes.ref;
          id += '/' + attributes.ref;
        }

        return { ...prevState,
          insertUsage: { ...prevState.insertUsage,
            [id]: {
              time: action.time,
              count: prevState.insertUsage[id] ? prevState.insertUsage[id].count + 1 : 1,
              insert
            }
          }
        };
      }, state);
  }

  return state;
}
/**
 * Reducer returning an object where each key is a block client ID, its value
 * representing the settings for its nested blocks.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Updated state.
 */

const blockListSettings = (state = {}, action) => {
  switch (action.type) {
    // Even if the replaced blocks have the same client ID, our logic
    // should correct the state.
    case 'REPLACE_BLOCKS':
    case 'REMOVE_BLOCKS':
      {
        return Object(lodash__WEBPACK_IMPORTED_MODULE_0__["omit"])(state, action.clientIds);
      }

    case 'UPDATE_BLOCK_LIST_SETTINGS':
      {
        const {
          clientId
        } = action;

        if (!action.settings) {
          if (state.hasOwnProperty(clientId)) {
            return Object(lodash__WEBPACK_IMPORTED_MODULE_0__["omit"])(state, clientId);
          }

          return state;
        }

        if (Object(lodash__WEBPACK_IMPORTED_MODULE_0__["isEqual"])(state[clientId], action.settings)) {
          return state;
        }

        return { ...state,
          [clientId]: action.settings
        };
      }
  }

  return state;
};
/**
 * Reducer returning whether the navigation mode is enabled or not.
 *
 * @param {string} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {string} Updated state.
 */

function isNavigationMode(state = false, action) {
  // Let inserting block always trigger Edit mode.
  if (action.type === 'INSERT_BLOCKS') {
    return false;
  }

  if (action.type === 'SET_NAVIGATION_MODE') {
    return action.isNavigationMode;
  }

  return state;
}
/**
 * Reducer returning whether the block moving mode is enabled or not.
 *
 * @param {string|null} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {string|null} Updated state.
 */

function hasBlockMovingClientId(state = null, action) {
  // Let inserting block always trigger Edit mode.
  if (action.type === 'SET_BLOCK_MOVING_MODE') {
    return action.hasBlockMovingClientId;
  }

  if (action.type === 'SET_NAVIGATION_MODE') {
    return null;
  }

  return state;
}
/**
 * Reducer return an updated state representing the most recent block attribute
 * update. The state is structured as an object where the keys represent the
 * client IDs of blocks, the values a subset of attributes from the most recent
 * block update. The state is always reset to null if the last action is
 * anything other than an attributes update.
 *
 * @param {Object<string,Object>} state  Current state.
 * @param {Object}                action Action object.
 *
 * @return {[string,Object]} Updated state.
 */

function lastBlockAttributesChange(state, action) {
  switch (action.type) {
    case 'UPDATE_BLOCK':
      if (!action.updates.attributes) {
        break;
      }

      return {
        [action.clientId]: action.updates.attributes
      };

    case 'UPDATE_BLOCK_ATTRIBUTES':
      return action.clientIds.reduce((accumulator, id) => ({ ...accumulator,
        [id]: action.uniqueByBlock ? action.attributes[id] : action.attributes
      }), {});
  }

  return null;
}
/**
 * Reducer returning automatic change state.
 *
 * @param {boolean} state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {string} Updated state.
 */

function automaticChangeStatus(state, action) {
  switch (action.type) {
    case 'MARK_AUTOMATIC_CHANGE':
      return 'pending';

    case 'MARK_AUTOMATIC_CHANGE_FINAL':
      if (state === 'pending') {
        return 'final';
      }

      return;

    case 'SELECTION_CHANGE':
      // As long as the state is not final, ignore any selection changes.
      if (state !== 'final') {
        return state;
      }

      return;
    // Undoing an automatic change should still be possible after mouse
    // move.

    case 'START_TYPING':
    case 'STOP_TYPING':
      return state;
  } // Reset the state by default (for any action not handled).

}
/**
 * Reducer returning current highlighted block.
 *
 * @param {boolean} state  Current highlighted block.
 * @param {Object}  action Dispatched action.
 *
 * @return {string} Updated state.
 */

function highlightedBlock(state, action) {
  switch (action.type) {
    case 'TOGGLE_BLOCK_HIGHLIGHT':
      const {
        clientId,
        isHighlighted
      } = action;

      if (isHighlighted) {
        return clientId;
      } else if (state === clientId) {
        return null;
      }

      return state;

    case 'SELECT_BLOCK':
      if (action.clientId !== state) {
        return null;
      }

  }

  return state;
}
/**
 * Reducer returning the block insertion event list state.
 *
 * @param {Object}  state  Current state.
 * @param {Object}  action Dispatched action.
 *
 * @return {Object} Updated state.
 */

function lastBlockInserted(state = {}, action) {
  var _action$meta;

  switch (action.type) {
    case 'INSERT_BLOCKS':
      if (!action.blocks.length) {
        return state;
      }

      const clientId = action.blocks[0].clientId;
      const source = (_action$meta = action.meta) === null || _action$meta === void 0 ? void 0 : _action$meta.source;
      return {
        clientId,
        source
      };

    case 'RESET_BLOCKS':
      return {};
  }

  return state;
}
/* harmony default export */ __webpack_exports__["default"] = (Object(_wordpress_data__WEBPACK_IMPORTED_MODULE_1__["combineReducers"])({
  blocks,
  isTyping,
  draggedBlocks,
  isCaretWithinFormattedText,
  selection,
  isMultiSelecting,
  isSelectionEnabled,
  initialPosition,
  blocksMode,
  blockListSettings,
  insertionPoint,
  template,
  settings,
  preferences,
  lastBlockAttributesChange,
  isNavigationMode,
  hasBlockMovingClientId,
  automaticChangeStatus,
  highlightedBlock,
  lastBlockInserted
}));
//# sourceMappingURL=reducer.js.map

/***/ }),

/***/ "FfR3":
/*!*****************************************************************************!*\
  !*** ../node_modules/@wordpress/block-editor/build-module/store/actions.js ***!
  \*****************************************************************************/
/*! exports provided: resetBlocks, validateBlocksToTemplate, resetSelection, receiveBlocks, updateBlockAttributes, updateBlock, selectBlock, selectPreviousBlock, selectNextBlock, startMultiSelect, stopMultiSelect, multiSelect, clearSelectedBlock, toggleSelection, replaceBlocks, replaceBlock, moveBlocksDown, moveBlocksUp, moveBlocksToPosition, moveBlockToPosition, insertBlock, insertBlocks, showInsertionPoint, hideInsertionPoint, setTemplateValidity, synchronizeTemplate, mergeBlocks, removeBlocks, removeBlock, replaceInnerBlocks, toggleBlockMode, startTyping, stopTyping, startDraggingBlocks, stopDraggingBlocks, enterFormattedText, exitFormattedText, selectionChange, insertDefaultBlock, updateBlockListSettings, updateSettings, __unstableSaveReusableBlock, __unstableMarkLastChangeAsPersistent, __unstableMarkNextChangeAsNotPersistent, __unstableMarkAutomaticChange, __unstableMarkAutomaticChangeFinal, setNavigationMode, setBlockMovingClientId, duplicateBlocks, insertBeforeBlock, insertAfterBlock, toggleBlockHighlight, flashBlock, setHasControlledInnerBlocks */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetBlocks", function() { return resetBlocks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateBlocksToTemplate", function() { return validateBlocksToTemplate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetSelection", function() { return resetSelection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "receiveBlocks", function() { return receiveBlocks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateBlockAttributes", function() { return updateBlockAttributes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateBlock", function() { return updateBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selectBlock", function() { return selectBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selectPreviousBlock", function() { return selectPreviousBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selectNextBlock", function() { return selectNextBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startMultiSelect", function() { return startMultiSelect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stopMultiSelect", function() { return stopMultiSelect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiSelect", function() { return multiSelect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearSelectedBlock", function() { return clearSelectedBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toggleSelection", function() { return toggleSelection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "replaceBlocks", function() { return replaceBlocks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "replaceBlock", function() { return replaceBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "moveBlocksDown", function() { return moveBlocksDown; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "moveBlocksUp", function() { return moveBlocksUp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "moveBlocksToPosition", function() { return moveBlocksToPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "moveBlockToPosition", function() { return moveBlockToPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertBlock", function() { return insertBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertBlocks", function() { return insertBlocks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "showInsertionPoint", function() { return showInsertionPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hideInsertionPoint", function() { return hideInsertionPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setTemplateValidity", function() { return setTemplateValidity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "synchronizeTemplate", function() { return synchronizeTemplate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeBlocks", function() { return mergeBlocks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeBlocks", function() { return removeBlocks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeBlock", function() { return removeBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "replaceInnerBlocks", function() { return replaceInnerBlocks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toggleBlockMode", function() { return toggleBlockMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startTyping", function() { return startTyping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stopTyping", function() { return stopTyping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startDraggingBlocks", function() { return startDraggingBlocks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stopDraggingBlocks", function() { return stopDraggingBlocks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enterFormattedText", function() { return enterFormattedText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exitFormattedText", function() { return exitFormattedText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selectionChange", function() { return selectionChange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertDefaultBlock", function() { return insertDefaultBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateBlockListSettings", function() { return updateBlockListSettings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateSettings", function() { return updateSettings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__unstableSaveReusableBlock", function() { return __unstableSaveReusableBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__unstableMarkLastChangeAsPersistent", function() { return __unstableMarkLastChangeAsPersistent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__unstableMarkNextChangeAsNotPersistent", function() { return __unstableMarkNextChangeAsNotPersistent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__unstableMarkAutomaticChange", function() { return __unstableMarkAutomaticChange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__unstableMarkAutomaticChangeFinal", function() { return __unstableMarkAutomaticChangeFinal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setNavigationMode", function() { return setNavigationMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setBlockMovingClientId", function() { return setBlockMovingClientId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "duplicateBlocks", function() { return duplicateBlocks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertBeforeBlock", function() { return insertBeforeBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertAfterBlock", function() { return insertAfterBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toggleBlockHighlight", function() { return toggleBlockHighlight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flashBlock", function() { return flashBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setHasControlledInnerBlocks", function() { return setHasControlledInnerBlocks; });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "9va6");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _wordpress_blocks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wordpress/blocks */ "f/Qs");
/* harmony import */ var _wordpress_a11y__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @wordpress/a11y */ "SlLs");
/* harmony import */ var _wordpress_i18n__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @wordpress/i18n */ "yAFj");
/* harmony import */ var _wordpress_data__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @wordpress/data */ "OgwO");
/* harmony import */ var _wordpress_rich_text__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @wordpress/rich-text */ "ZhTL");
/* harmony import */ var _wordpress_deprecated__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @wordpress/deprecated */ "OY0d");
/* harmony import */ var _store_controls__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../store/controls */ "VGZE");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./constants */ "Gg2m");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */







/**
 * Internal dependencies
 */



/**
 * Generator which will yield a default block insert action if there
 * are no other blocks at the root of the editor. This generator should be used
 * in actions which may result in no blocks remaining in the editor (removal,
 * replacement, etc).
 */

function* ensureDefaultBlock() {
  const count = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getBlockCount'); // To avoid a focus loss when removing the last block, assure there is
  // always a default block if the last of the blocks have been removed.

  if (count === 0) {
    const {
      __unstableHasCustomAppender
    } = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getSettings'); // If there's an custom appender, don't insert default block.
    // We have to remember to manually move the focus elsewhere to
    // prevent it from being lost though.

    if (__unstableHasCustomAppender) {
      return;
    }

    return yield insertDefaultBlock();
  }
}
/**
 * Returns an action object used in signalling that blocks state should be
 * reset to the specified array of blocks, taking precedence over any other
 * content reflected as an edit in state.
 *
 * @param {Array} blocks Array of blocks.
 */


function* resetBlocks(blocks) {
  yield {
    type: 'RESET_BLOCKS',
    blocks
  };
  return yield* validateBlocksToTemplate(blocks);
}
/**
 * Block validity is a function of blocks state (at the point of a
 * reset) and the template setting. As a compromise to its placement
 * across distinct parts of state, it is implemented here as a side-
 * effect of the block reset action.
 *
 * @param {Array} blocks Array of blocks.
 */

function* validateBlocksToTemplate(blocks) {
  const template = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getTemplate');
  const templateLock = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getTemplateLock'); // Unlocked templates are considered always valid because they act
  // as default values only.

  const isBlocksValidToTemplate = !template || templateLock !== 'all' || Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_1__["doBlocksMatchTemplate"])(blocks, template); // Update if validity has changed.

  const isValidTemplate = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'isValidTemplate');

  if (isBlocksValidToTemplate !== isValidTemplate) {
    yield setTemplateValidity(isBlocksValidToTemplate);
    return isBlocksValidToTemplate;
  }
}
/**
 * A block selection object.
 *
 * @typedef {Object} WPBlockSelection
 *
 * @property {string} clientId     A block client ID.
 * @property {string} attributeKey A block attribute key.
 * @property {number} offset       An attribute value offset, based on the rich
 *                                 text value. See `wp.richText.create`.
 */

/**
 * Returns an action object used in signalling that selection state should be
 * reset to the specified selection.
 *
 * @param {WPBlockSelection} selectionStart  The selection start.
 * @param {WPBlockSelection} selectionEnd    The selection end.
 * @param {0|-1|null}        initialPosition Initial block position.
 *
 * @return {Object} Action object.
 */

function resetSelection(selectionStart, selectionEnd, initialPosition) {
  return {
    type: 'RESET_SELECTION',
    selectionStart,
    selectionEnd,
    initialPosition
  };
}
/**
 * Returns an action object used in signalling that blocks have been received.
 * Unlike resetBlocks, these should be appended to the existing known set, not
 * replacing.
 *
 * @param {Object[]} blocks Array of block objects.
 *
 * @return {Object} Action object.
 */

function receiveBlocks(blocks) {
  return {
    type: 'RECEIVE_BLOCKS',
    blocks
  };
}
/**
 * Returns an action object used in signalling that the multiple blocks'
 * attributes with the specified client IDs have been updated.
 *
 * @param {string|string[]} clientIds  Block client IDs.
 * @param {Object}          attributes Block attributes to be merged. Should be keyed by clientIds if
 * uniqueByBlock is true.
 * @param {boolean}          uniqueByBlock true if each block in clientIds array has a unique set of attributes
 * @return {Object} Action object.
 */

function updateBlockAttributes(clientIds, attributes, uniqueByBlock = false) {
  return {
    type: 'UPDATE_BLOCK_ATTRIBUTES',
    clientIds: Object(lodash__WEBPACK_IMPORTED_MODULE_0__["castArray"])(clientIds),
    attributes,
    uniqueByBlock
  };
}
/**
 * Returns an action object used in signalling that the block with the
 * specified client ID has been updated.
 *
 * @param {string} clientId Block client ID.
 * @param {Object} updates  Block attributes to be merged.
 *
 * @return {Object} Action object.
 */

function updateBlock(clientId, updates) {
  return {
    type: 'UPDATE_BLOCK',
    clientId,
    updates
  };
}
/**
 * Returns an action object used in signalling that the block with the
 * specified client ID has been selected, optionally accepting a position
 * value reflecting its selection directionality. An initialPosition of -1
 * reflects a reverse selection.
 *
 * @param {string}    clientId        Block client ID.
 * @param {0|-1|null} initialPosition Optional initial position. Pass as -1 to
 *                                  reflect reverse selection.
 *
 * @return {Object} Action object.
 */

function selectBlock(clientId, initialPosition = 0) {
  return {
    type: 'SELECT_BLOCK',
    initialPosition,
    clientId
  };
}
/**
 * Yields action objects used in signalling that the block preceding the given
 * clientId should be selected.
 *
 * @param {string} clientId Block client ID.
 */

function* selectPreviousBlock(clientId) {
  const previousBlockClientId = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getPreviousBlockClientId', clientId);

  if (previousBlockClientId) {
    yield selectBlock(previousBlockClientId, -1);
    return [previousBlockClientId];
  }
}
/**
 * Yields action objects used in signalling that the block following the given
 * clientId should be selected.
 *
 * @param {string} clientId Block client ID.
 */

function* selectNextBlock(clientId) {
  const nextBlockClientId = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getNextBlockClientId', clientId);

  if (nextBlockClientId) {
    yield selectBlock(nextBlockClientId);
    return [nextBlockClientId];
  }
}
/**
 * Returns an action object used in signalling that a block multi-selection has started.
 *
 * @return {Object} Action object.
 */

function startMultiSelect() {
  return {
    type: 'START_MULTI_SELECT'
  };
}
/**
 * Returns an action object used in signalling that block multi-selection stopped.
 *
 * @return {Object} Action object.
 */

function stopMultiSelect() {
  return {
    type: 'STOP_MULTI_SELECT'
  };
}
/**
 * Returns an action object used in signalling that block multi-selection changed.
 *
 * @param {string} start First block of the multi selection.
 * @param {string} end   Last block of the multiselection.
 */

function* multiSelect(start, end) {
  const startBlockRootClientId = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getBlockRootClientId', start);
  const endBlockRootClientId = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getBlockRootClientId', end); // Only allow block multi-selections at the same level.

  if (startBlockRootClientId !== endBlockRootClientId) {
    return;
  }

  yield {
    type: 'MULTI_SELECT',
    start,
    end
  };
  const blockCount = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getSelectedBlockCount');
  Object(_wordpress_a11y__WEBPACK_IMPORTED_MODULE_2__["speak"])(Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_3__["sprintf"])(
  /* translators: %s: number of selected blocks */
  Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_3__["_n"])('%s block selected.', '%s blocks selected.', blockCount), blockCount), 'assertive');
}
/**
 * Returns an action object used in signalling that the block selection is cleared.
 *
 * @return {Object} Action object.
 */

function clearSelectedBlock() {
  return {
    type: 'CLEAR_SELECTED_BLOCK'
  };
}
/**
 * Returns an action object that enables or disables block selection.
 *
 * @param {boolean} [isSelectionEnabled=true] Whether block selection should
 *                                            be enabled.
 *
 * @return {Object} Action object.
 */

function toggleSelection(isSelectionEnabled = true) {
  return {
    type: 'TOGGLE_SELECTION',
    isSelectionEnabled
  };
}

function getBlocksWithDefaultStylesApplied(blocks, blockEditorSettings) {
  var _blockEditorSettings$, _blockEditorSettings$2;

  const preferredStyleVariations = (_blockEditorSettings$ = blockEditorSettings === null || blockEditorSettings === void 0 ? void 0 : (_blockEditorSettings$2 = blockEditorSettings.__experimentalPreferredStyleVariations) === null || _blockEditorSettings$2 === void 0 ? void 0 : _blockEditorSettings$2.value) !== null && _blockEditorSettings$ !== void 0 ? _blockEditorSettings$ : {};
  return blocks.map(block => {
    var _block$attributes;

    const blockName = block.name;

    if (!Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_1__["hasBlockSupport"])(blockName, 'defaultStylePicker', true)) {
      return block;
    }

    if (!preferredStyleVariations[blockName]) {
      return block;
    }

    const className = (_block$attributes = block.attributes) === null || _block$attributes === void 0 ? void 0 : _block$attributes.className;

    if (className !== null && className !== void 0 && className.includes('is-style-')) {
      return block;
    }

    const {
      attributes = {}
    } = block;
    const blockStyle = preferredStyleVariations[blockName];
    return { ...block,
      attributes: { ...attributes,
        className: `${className || ''} is-style-${blockStyle}`.trim()
      }
    };
  });
}
/**
 * Returns an action object signalling that a blocks should be replaced with
 * one or more replacement blocks.
 *
 * @param {(string|string[])} clientIds       Block client ID(s) to replace.
 * @param {(Object|Object[])} blocks          Replacement block(s).
 * @param {number}            indexToSelect   Index of replacement block to select.
 * @param {0|-1|null}         initialPosition Index of caret after in the selected block after the operation.
 * @param {?Object}           meta            Optional Meta values to be passed to the action object.
 *
 * @yield {Object} Action object.
 */


function* replaceBlocks(clientIds, blocks, indexToSelect, initialPosition = 0, meta) {
  clientIds = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["castArray"])(clientIds);
  blocks = getBlocksWithDefaultStylesApplied(Object(lodash__WEBPACK_IMPORTED_MODULE_0__["castArray"])(blocks), yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getSettings'));
  const rootClientId = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getBlockRootClientId', Object(lodash__WEBPACK_IMPORTED_MODULE_0__["first"])(clientIds)); // Replace is valid if the new blocks can be inserted in the root block.

  for (let index = 0; index < blocks.length; index++) {
    const block = blocks[index];
    const canInsertBlock = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'canInsertBlockType', block.name, rootClientId);

    if (!canInsertBlock) {
      return;
    }
  }

  yield {
    type: 'REPLACE_BLOCKS',
    clientIds,
    blocks,
    time: Date.now(),
    indexToSelect,
    initialPosition,
    meta
  };
  yield* ensureDefaultBlock();
}
/**
 * Returns an action object signalling that a single block should be replaced
 * with one or more replacement blocks.
 *
 * @param {(string|string[])} clientId Block client ID to replace.
 * @param {(Object|Object[])} block    Replacement block(s).
 *
 * @return {Object} Action object.
 */

function replaceBlock(clientId, block) {
  return replaceBlocks(clientId, block);
}
/**
 * Higher-order action creator which, given the action type to dispatch creates
 * an action creator for managing block movement.
 *
 * @param {string} type Action type to dispatch.
 *
 * @return {Function} Action creator.
 */

function createOnMove(type) {
  return (clientIds, rootClientId) => {
    return {
      clientIds: Object(lodash__WEBPACK_IMPORTED_MODULE_0__["castArray"])(clientIds),
      type,
      rootClientId
    };
  };
}

const moveBlocksDown = createOnMove('MOVE_BLOCKS_DOWN');
const moveBlocksUp = createOnMove('MOVE_BLOCKS_UP');
/**
 * Returns an action object signalling that the given blocks should be moved to
 * a new position.
 *
 * @param  {?string} clientIds        The client IDs of the blocks.
 * @param  {?string} fromRootClientId Root client ID source.
 * @param  {?string} toRootClientId   Root client ID destination.
 * @param  {number}  index            The index to move the blocks to.
 *
 * @yield {Object} Action object.
 */

function* moveBlocksToPosition(clientIds, fromRootClientId = '', toRootClientId = '', index) {
  const templateLock = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getTemplateLock', fromRootClientId); // If locking is equal to all on the original clientId (fromRootClientId),
  // it is not possible to move the block to any other position.

  if (templateLock === 'all') {
    return;
  }

  const action = {
    type: 'MOVE_BLOCKS_TO_POSITION',
    fromRootClientId,
    toRootClientId,
    clientIds,
    index
  }; // If moving inside the same root block the move is always possible.

  if (fromRootClientId === toRootClientId) {
    yield action;
    return;
  } // If templateLock is insert we can not remove the block from the parent.
  // Given that here we know that we are moving the block to a different
  // parent, the move should not be possible if the condition is true.


  if (templateLock === 'insert') {
    return;
  }

  const canInsertBlocks = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'canInsertBlocks', clientIds, toRootClientId); // If moving to other parent block, the move is possible if we can insert a block of the same type inside the new parent block.

  if (canInsertBlocks) {
    yield action;
  }
}
/**
 * Returns an action object signalling that the given block should be moved to a
 * new position.
 *
 * @param  {?string} clientId         The client ID of the block.
 * @param  {?string} fromRootClientId Root client ID source.
 * @param  {?string} toRootClientId   Root client ID destination.
 * @param  {number}  index            The index to move the block to.
 *
 * @yield {Object} Action object.
 */

function* moveBlockToPosition(clientId, fromRootClientId = '', toRootClientId = '', index) {
  yield moveBlocksToPosition([clientId], fromRootClientId, toRootClientId, index);
}
/**
 * Returns an action object used in signalling that a single block should be
 * inserted, optionally at a specific index respective a root block list.
 *
 * @param {Object}  block            Block object to insert.
 * @param {?number} index            Index at which block should be inserted.
 * @param {?string} rootClientId     Optional root client ID of block list on which to insert.
 * @param {?boolean} updateSelection If true block selection will be updated. If false, block selection will not change. Defaults to true.
 * @param {?Object} meta             Optional Meta values to be passed to the action object.
 *
 * @return {Object} Action object.
 */

function insertBlock(block, index, rootClientId, updateSelection = true, meta) {
  return insertBlocks([block], index, rootClientId, updateSelection, 0, meta);
}
/**
 * Returns an action object used in signalling that an array of blocks should
 * be inserted, optionally at a specific index respective a root block list.
 *
 * @param {Object[]}  blocks          Block objects to insert.
 * @param {?number}   index           Index at which block should be inserted.
 * @param {?string}   rootClientId    Optional root client ID of block list on which to insert.
 * @param {?boolean}  updateSelection If true block selection will be updated.  If false, block selection will not change. Defaults to true.
 * @param {0|-1|null} initialPosition Initial focus position. Setting it to null prevent focusing the inserted block.
 * @param {?Object}   meta            Optional Meta values to be passed to the action object.
 * @return {Object} Action object.
 */

function* insertBlocks(blocks, index, rootClientId, updateSelection = true, initialPosition = 0, meta) {
  if (Object(lodash__WEBPACK_IMPORTED_MODULE_0__["isObject"])(initialPosition)) {
    meta = initialPosition;
    initialPosition = 0;
    Object(_wordpress_deprecated__WEBPACK_IMPORTED_MODULE_6__["default"])("meta argument in wp.data.dispatch('core/block-editor')", {
      since: '10.1',
      plugin: 'Gutenberg',
      hint: 'The meta argument is now the 6th argument of the function'
    });
  }

  blocks = getBlocksWithDefaultStylesApplied(Object(lodash__WEBPACK_IMPORTED_MODULE_0__["castArray"])(blocks), yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getSettings'));
  const allowedBlocks = [];

  for (const block of blocks) {
    const isValid = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'canInsertBlockType', block.name, rootClientId);

    if (isValid) {
      allowedBlocks.push(block);
    }
  }

  if (allowedBlocks.length) {
    return {
      type: 'INSERT_BLOCKS',
      blocks: allowedBlocks,
      index,
      rootClientId,
      time: Date.now(),
      updateSelection,
      initialPosition: updateSelection ? initialPosition : null,
      meta
    };
  }
}
/**
 * Returns an action object used in signalling that the insertion point should
 * be shown.
 *
 * @param {?string} rootClientId Optional root client ID of block list on
 *                               which to insert.
 * @param {?number} index        Index at which block should be inserted.
 * @param {Object}  __unstableOptions Wether or not to show an inserter button.
 *
 * @return {Object} Action object.
 */

function showInsertionPoint(rootClientId, index, __unstableOptions = {}) {
  const {
    __unstableWithInserter
  } = __unstableOptions;
  return {
    type: 'SHOW_INSERTION_POINT',
    rootClientId,
    index,
    __unstableWithInserter
  };
}
/**
 * Returns an action object hiding the insertion point.
 *
 * @return {Object} Action object.
 */

function hideInsertionPoint() {
  return {
    type: 'HIDE_INSERTION_POINT'
  };
}
/**
 * Returns an action object resetting the template validity.
 *
 * @param {boolean}  isValid  template validity flag.
 *
 * @return {Object} Action object.
 */

function setTemplateValidity(isValid) {
  return {
    type: 'SET_TEMPLATE_VALIDITY',
    isValid
  };
}
/**
 * Returns an action object synchronize the template with the list of blocks
 *
 * @return {Object} Action object.
 */

function* synchronizeTemplate() {
  yield {
    type: 'SYNCHRONIZE_TEMPLATE'
  };
  const blocks = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getBlocks');
  const template = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getTemplate');
  const updatedBlockList = Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_1__["synchronizeBlocksWithTemplate"])(blocks, template);
  return yield resetBlocks(updatedBlockList);
}
/**
 * Returns an action object used in signalling that two blocks should be merged
 *
 * @param {string} firstBlockClientId  Client ID of the first block to merge.
 * @param {string} secondBlockClientId Client ID of the second block to merge.
 */

function* mergeBlocks(firstBlockClientId, secondBlockClientId) {
  const blocks = [firstBlockClientId, secondBlockClientId];
  yield {
    type: 'MERGE_BLOCKS',
    blocks
  };
  const [clientIdA, clientIdB] = blocks;
  const blockA = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getBlock', clientIdA);
  const blockAType = Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_1__["getBlockType"])(blockA.name); // Only focus the previous block if it's not mergeable

  if (!blockAType.merge) {
    yield selectBlock(blockA.clientId);
    return;
  }

  const blockB = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getBlock', clientIdB);
  const blockBType = Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_1__["getBlockType"])(blockB.name);
  const {
    clientId,
    attributeKey,
    offset
  } = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getSelectionStart');
  const selectedBlockType = clientId === clientIdA ? blockAType : blockBType;
  const attributeDefinition = selectedBlockType.attributes[attributeKey];
  const canRestoreTextSelection = (clientId === clientIdA || clientId === clientIdB) && attributeKey !== undefined && offset !== undefined && // We cannot restore text selection if the RichText identifier
  // is not a defined block attribute key. This can be the case if the
  // fallback intance ID is used to store selection (and no RichText
  // identifier is set), or when the identifier is wrong.
  !!attributeDefinition;

  if (!attributeDefinition) {
    if (typeof attributeKey === 'number') {
      window.console.error(`RichText needs an identifier prop that is the block attribute key of the attribute it controls. Its type is expected to be a string, but was ${typeof attributeKey}`);
    } else {
      window.console.error('The RichText identifier prop does not match any attributes defined by the block.');
    }
  } // A robust way to retain selection position through various transforms
  // is to insert a special character at the position and then recover it.


  const START_OF_SELECTED_AREA = '\u0086'; // Clone the blocks so we don't insert the character in a "live" block.

  const cloneA = Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_1__["cloneBlock"])(blockA);
  const cloneB = Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_1__["cloneBlock"])(blockB);

  if (canRestoreTextSelection) {
    const selectedBlock = clientId === clientIdA ? cloneA : cloneB;
    const html = selectedBlock.attributes[attributeKey];
    const {
      multiline: multilineTag,
      __unstableMultilineWrapperTags: multilineWrapperTags,
      __unstablePreserveWhiteSpace: preserveWhiteSpace
    } = attributeDefinition;
    const value = Object(_wordpress_rich_text__WEBPACK_IMPORTED_MODULE_5__["insert"])(Object(_wordpress_rich_text__WEBPACK_IMPORTED_MODULE_5__["create"])({
      html,
      multilineTag,
      multilineWrapperTags,
      preserveWhiteSpace
    }), START_OF_SELECTED_AREA, offset, offset);
    selectedBlock.attributes[attributeKey] = Object(_wordpress_rich_text__WEBPACK_IMPORTED_MODULE_5__["toHTMLString"])({
      value,
      multilineTag,
      preserveWhiteSpace
    });
  } // We can only merge blocks with similar types
  // thus, we transform the block to merge first


  const blocksWithTheSameType = blockA.name === blockB.name ? [cloneB] : Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_1__["switchToBlockType"])(cloneB, blockA.name); // If the block types can not match, do nothing

  if (!blocksWithTheSameType || !blocksWithTheSameType.length) {
    return;
  } // Calling the merge to update the attributes and remove the block to be merged


  const updatedAttributes = blockAType.merge(cloneA.attributes, blocksWithTheSameType[0].attributes);

  if (canRestoreTextSelection) {
    const newAttributeKey = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["findKey"])(updatedAttributes, v => typeof v === 'string' && v.indexOf(START_OF_SELECTED_AREA) !== -1);
    const convertedHtml = updatedAttributes[newAttributeKey];
    const {
      multiline: multilineTag,
      __unstableMultilineWrapperTags: multilineWrapperTags,
      __unstablePreserveWhiteSpace: preserveWhiteSpace
    } = blockAType.attributes[newAttributeKey];
    const convertedValue = Object(_wordpress_rich_text__WEBPACK_IMPORTED_MODULE_5__["create"])({
      html: convertedHtml,
      multilineTag,
      multilineWrapperTags,
      preserveWhiteSpace
    });
    const newOffset = convertedValue.text.indexOf(START_OF_SELECTED_AREA);
    const newValue = Object(_wordpress_rich_text__WEBPACK_IMPORTED_MODULE_5__["remove"])(convertedValue, newOffset, newOffset + 1);
    const newHtml = Object(_wordpress_rich_text__WEBPACK_IMPORTED_MODULE_5__["toHTMLString"])({
      value: newValue,
      multilineTag,
      preserveWhiteSpace
    });
    updatedAttributes[newAttributeKey] = newHtml;
    yield selectionChange(blockA.clientId, newAttributeKey, newOffset, newOffset);
  }

  yield* replaceBlocks([blockA.clientId, blockB.clientId], [{ ...blockA,
    attributes: { ...blockA.attributes,
      ...updatedAttributes
    }
  }, ...blocksWithTheSameType.slice(1)]);
}
/**
 * Yields action objects used in signalling that the blocks corresponding to
 * the set of specified client IDs are to be removed.
 *
 * @param {string|string[]} clientIds      Client IDs of blocks to remove.
 * @param {boolean}         selectPrevious True if the previous block should be
 *                                         selected when a block is removed.
 */

function* removeBlocks(clientIds, selectPrevious = true) {
  if (!clientIds || !clientIds.length) {
    return;
  }

  clientIds = Object(lodash__WEBPACK_IMPORTED_MODULE_0__["castArray"])(clientIds);
  const rootClientId = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getBlockRootClientId', clientIds[0]);
  const isLocked = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getTemplateLock', rootClientId);

  if (isLocked) {
    return;
  }

  let previousBlockId;

  if (selectPrevious) {
    previousBlockId = yield selectPreviousBlock(clientIds[0]);
  } else {
    previousBlockId = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getPreviousBlockClientId', clientIds[0]);
  }

  yield {
    type: 'REMOVE_BLOCKS',
    clientIds
  }; // To avoid a focus loss when removing the last block, assure there is
  // always a default block if the last of the blocks have been removed.

  const defaultBlockId = yield* ensureDefaultBlock();
  return [previousBlockId || defaultBlockId];
}
/**
 * Returns an action object used in signalling that the block with the
 * specified client ID is to be removed.
 *
 * @param {string}  clientId       Client ID of block to remove.
 * @param {boolean} selectPrevious True if the previous block should be
 *                                 selected when a block is removed.
 *
 * @return {Object} Action object.
 */

function removeBlock(clientId, selectPrevious) {
  return removeBlocks([clientId], selectPrevious);
}
/**
 * Returns an action object used in signalling that the inner blocks with the
 * specified client ID should be replaced.
 *
 * @param {string}    rootClientId    Client ID of the block whose InnerBlocks will re replaced.
 * @param {Object[]}  blocks          Block objects to insert as new InnerBlocks
 * @param {?boolean}  updateSelection If true block selection will be updated. If false, block selection will not change. Defaults to false.
 * @param {0|-1|null} initialPosition Initial block position.
 * @return {Object} Action object.
 */

function replaceInnerBlocks(rootClientId, blocks, updateSelection = false, initialPosition = 0) {
  return {
    type: 'REPLACE_INNER_BLOCKS',
    rootClientId,
    blocks,
    updateSelection,
    initialPosition: updateSelection ? initialPosition : null,
    time: Date.now()
  };
}
/**
 * Returns an action object used to toggle the block editing mode between
 * visual and HTML modes.
 *
 * @param {string} clientId Block client ID.
 *
 * @return {Object} Action object.
 */

function toggleBlockMode(clientId) {
  return {
    type: 'TOGGLE_BLOCK_MODE',
    clientId
  };
}
/**
 * Returns an action object used in signalling that the user has begun to type.
 *
 * @return {Object} Action object.
 */

function startTyping() {
  return {
    type: 'START_TYPING'
  };
}
/**
 * Returns an action object used in signalling that the user has stopped typing.
 *
 * @return {Object} Action object.
 */

function stopTyping() {
  return {
    type: 'STOP_TYPING'
  };
}
/**
 * Returns an action object used in signalling that the user has begun to drag blocks.
 *
 * @param {string[]} clientIds An array of client ids being dragged
 *
 * @return {Object} Action object.
 */

function startDraggingBlocks(clientIds = []) {
  return {
    type: 'START_DRAGGING_BLOCKS',
    clientIds
  };
}
/**
 * Returns an action object used in signalling that the user has stopped dragging blocks.
 *
 * @return {Object} Action object.
 */

function stopDraggingBlocks() {
  return {
    type: 'STOP_DRAGGING_BLOCKS'
  };
}
/**
 * Returns an action object used in signalling that the caret has entered formatted text.
 *
 * @return {Object} Action object.
 */

function enterFormattedText() {
  return {
    type: 'ENTER_FORMATTED_TEXT'
  };
}
/**
 * Returns an action object used in signalling that the user caret has exited formatted text.
 *
 * @return {Object} Action object.
 */

function exitFormattedText() {
  return {
    type: 'EXIT_FORMATTED_TEXT'
  };
}
/**
 * Returns an action object used in signalling that the user caret has changed
 * position.
 *
 * @param {string} clientId     The selected block client ID.
 * @param {string} attributeKey The selected block attribute key.
 * @param {number} startOffset  The start offset.
 * @param {number} endOffset    The end offset.
 *
 * @return {Object} Action object.
 */

function selectionChange(clientId, attributeKey, startOffset, endOffset) {
  return {
    type: 'SELECTION_CHANGE',
    clientId,
    attributeKey,
    startOffset,
    endOffset
  };
}
/**
 * Returns an action object used in signalling that a new block of the default
 * type should be added to the block list.
 *
 * @param {?Object} attributes   Optional attributes of the block to assign.
 * @param {?string} rootClientId Optional root client ID of block list on which
 *                               to append.
 * @param {?number} index        Optional index where to insert the default block
 *
 * @return {Object} Action object
 */

function insertDefaultBlock(attributes, rootClientId, index) {
  // Abort if there is no default block type (if it has been unregistered).
  const defaultBlockName = Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_1__["getDefaultBlockName"])();

  if (!defaultBlockName) {
    return;
  }

  const block = Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_1__["createBlock"])(defaultBlockName, attributes);
  return insertBlock(block, index, rootClientId);
}
/**
 * Returns an action object that changes the nested settings of a given block.
 *
 * @param {string} clientId Client ID of the block whose nested setting are
 *                          being received.
 * @param {Object} settings Object with the new settings for the nested block.
 *
 * @return {Object} Action object
 */

function updateBlockListSettings(clientId, settings) {
  return {
    type: 'UPDATE_BLOCK_LIST_SETTINGS',
    clientId,
    settings
  };
}
/**
 * Returns an action object used in signalling that the block editor settings have been updated.
 *
 * @param {Object} settings Updated settings
 *
 * @return {Object} Action object
 */

function updateSettings(settings) {
  return {
    type: 'UPDATE_SETTINGS',
    settings
  };
}
/**
 * Returns an action object used in signalling that a temporary reusable blocks have been saved
 * in order to switch its temporary id with the real id.
 *
 * @param {string} id        Reusable block's id.
 * @param {string} updatedId Updated block's id.
 *
 * @return {Object} Action object.
 */

function __unstableSaveReusableBlock(id, updatedId) {
  return {
    type: 'SAVE_REUSABLE_BLOCK_SUCCESS',
    id,
    updatedId
  };
}
/**
 * Returns an action object used in signalling that the last block change should be marked explicitly as persistent.
 *
 * @return {Object} Action object.
 */

function __unstableMarkLastChangeAsPersistent() {
  return {
    type: 'MARK_LAST_CHANGE_AS_PERSISTENT'
  };
}
/**
 * Returns an action object used in signalling that the next block change should be marked explicitly as not persistent.
 *
 * @return {Object} Action object.
 */

function __unstableMarkNextChangeAsNotPersistent() {
  return {
    type: 'MARK_NEXT_CHANGE_AS_NOT_PERSISTENT'
  };
}
/**
 * Returns an action object used in signalling that the last block change is
 * an automatic change, meaning it was not performed by the user, and can be
 * undone using the `Escape` and `Backspace` keys. This action must be called
 * after the change was made, and any actions that are a consequence of it, so
 * it is recommended to be called at the next idle period to ensure all
 * selection changes have been recorded.
 */

function* __unstableMarkAutomaticChange() {
  yield {
    type: 'MARK_AUTOMATIC_CHANGE'
  };
  yield Object(_store_controls__WEBPACK_IMPORTED_MODULE_7__["__unstableMarkAutomaticChangeFinalControl"])();
}
function __unstableMarkAutomaticChangeFinal() {
  return {
    type: 'MARK_AUTOMATIC_CHANGE_FINAL'
  };
}
/**
 * Generators that triggers an action used to enable or disable the navigation mode.
 *
 * @param {string} isNavigationMode Enable/Disable navigation mode.
 */

function* setNavigationMode(isNavigationMode = true) {
  yield {
    type: 'SET_NAVIGATION_MODE',
    isNavigationMode
  };

  if (isNavigationMode) {
    Object(_wordpress_a11y__WEBPACK_IMPORTED_MODULE_2__["speak"])(Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_3__["__"])('You are currently in navigation mode. Navigate blocks using the Tab key and Arrow keys. Use Left and Right Arrow keys to move between nesting levels. To exit navigation mode and edit the selected block, press Enter.'));
  } else {
    Object(_wordpress_a11y__WEBPACK_IMPORTED_MODULE_2__["speak"])(Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_3__["__"])('You are currently in edit mode. To return to the navigation mode, press Escape.'));
  }
}
/**
 * Generator that triggers an action used to enable or disable the block moving mode.
 *
 * @param {string|null} hasBlockMovingClientId Enable/Disable block moving mode.
 */

function* setBlockMovingClientId(hasBlockMovingClientId = null) {
  yield {
    type: 'SET_BLOCK_MOVING_MODE',
    hasBlockMovingClientId
  };

  if (hasBlockMovingClientId) {
    Object(_wordpress_a11y__WEBPACK_IMPORTED_MODULE_2__["speak"])(Object(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_3__["__"])('Use the Tab key and Arrow keys to choose new block location. Use Left and Right Arrow keys to move between nesting levels. Once location is selected press Enter or Space to move the block.'));
  }
}
/**
 * Generator that triggers an action used to duplicate a list of blocks.
 *
 * @param {string[]} clientIds
 * @param {boolean} updateSelection
 */

function* duplicateBlocks(clientIds, updateSelection = true) {
  if (!clientIds && !clientIds.length) {
    return;
  }

  const blocks = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getBlocksByClientId', clientIds);
  const rootClientId = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getBlockRootClientId', clientIds[0]); // Return early if blocks don't exist.

  if (Object(lodash__WEBPACK_IMPORTED_MODULE_0__["some"])(blocks, block => !block)) {
    return;
  }

  const blockNames = blocks.map(block => block.name); // Return early if blocks don't support multiple usage.

  if (Object(lodash__WEBPACK_IMPORTED_MODULE_0__["some"])(blockNames, blockName => !Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_1__["hasBlockSupport"])(blockName, 'multiple', true))) {
    return;
  }

  const lastSelectedIndex = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getBlockIndex', Object(lodash__WEBPACK_IMPORTED_MODULE_0__["last"])(Object(lodash__WEBPACK_IMPORTED_MODULE_0__["castArray"])(clientIds)), rootClientId);
  const clonedBlocks = blocks.map(block => Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_1__["__experimentalCloneSanitizedBlock"])(block));
  yield insertBlocks(clonedBlocks, lastSelectedIndex + 1, rootClientId, updateSelection);

  if (clonedBlocks.length > 1 && updateSelection) {
    yield multiSelect(Object(lodash__WEBPACK_IMPORTED_MODULE_0__["first"])(clonedBlocks).clientId, Object(lodash__WEBPACK_IMPORTED_MODULE_0__["last"])(clonedBlocks).clientId);
  }

  return clonedBlocks.map(block => block.clientId);
}
/**
 * Generator used to insert an empty block after a given block.
 *
 * @param {string} clientId
 */

function* insertBeforeBlock(clientId) {
  if (!clientId) {
    return;
  }

  const rootClientId = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getBlockRootClientId', clientId);
  const isLocked = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getTemplateLock', rootClientId);

  if (isLocked) {
    return;
  }

  const firstSelectedIndex = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getBlockIndex', clientId, rootClientId);
  return yield insertDefaultBlock({}, rootClientId, firstSelectedIndex);
}
/**
 * Generator used to insert an empty block before a given block.
 *
 * @param {string} clientId
 */

function* insertAfterBlock(clientId) {
  if (!clientId) {
    return;
  }

  const rootClientId = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getBlockRootClientId', clientId);
  const isLocked = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getTemplateLock', rootClientId);

  if (isLocked) {
    return;
  }

  const firstSelectedIndex = yield _wordpress_data__WEBPACK_IMPORTED_MODULE_4__["controls"].select(_constants__WEBPACK_IMPORTED_MODULE_8__["STORE_NAME"], 'getBlockIndex', clientId, rootClientId);
  return yield insertDefaultBlock({}, rootClientId, firstSelectedIndex + 1);
}
/**
 * Returns an action object that toggles the highlighted block state.
 *
 * @param {string} clientId The block's clientId.
 * @param {boolean} isHighlighted The highlight state.
 */

function toggleBlockHighlight(clientId, isHighlighted) {
  return {
    type: 'TOGGLE_BLOCK_HIGHLIGHT',
    clientId,
    isHighlighted
  };
}
/**
 * Yields action objects used in signalling that the block corresponding to the
 * given clientId should appear to "flash" by rhythmically highlighting it.
 *
 * @param {string} clientId Target block client ID.
 */

function* flashBlock(clientId) {
  yield toggleBlockHighlight(clientId, true);
  yield {
    type: 'SLEEP',
    duration: 150
  };
  yield toggleBlockHighlight(clientId, false);
}
/**
 * Returns an action object that sets whether the block has controlled innerblocks.
 *
 * @param {string} clientId The block's clientId.
 * @param {boolean} hasControlledInnerBlocks True if the block's inner blocks are controlled.
 */

function setHasControlledInnerBlocks(clientId, hasControlledInnerBlocks) {
  return {
    type: 'SET_HAS_CONTROLLED_INNER_BLOCKS',
    hasControlledInnerBlocks,
    clientId
  };
}
//# sourceMappingURL=actions.js.map

/***/ }),

/***/ "Gay7":
/*!*************************************************************************************************************!*\
  !*** ../node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/stringify/compress.js ***!
  \*************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "whF7");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _compiler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compiler */ "PKgW");
// Adapted from https://github.com/reworkcss/css
// because we needed to remove source map support.

/**
 * External dependencies
 */

/**
 * Internal dependencies
 */


/**
 * Expose compiler.
 */

/* harmony default export */ __webpack_exports__["default"] = (Compiler);
/**
 * Initialize a new `Compiler`.
 */

function Compiler(options) {
  _compiler__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, options);
}
/**
 * Inherit from `Base.prototype`.
 */


inherits__WEBPACK_IMPORTED_MODULE_0___default()(Compiler, _compiler__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * Compile `node`.
 */

Compiler.prototype.compile = function (node) {
  return node.stylesheet.rules.map(this.visit, this).join('');
};
/**
 * Visit comment node.
 */


Compiler.prototype.comment = function (node) {
  return this.emit('', node.position);
};
/**
 * Visit import node.
 */


Compiler.prototype.import = function (node) {
  return this.emit('@import ' + node.import + ';', node.position);
};
/**
 * Visit media node.
 */


Compiler.prototype.media = function (node) {
  return this.emit('@media ' + node.media, node.position) + this.emit('{') + this.mapVisit(node.rules) + this.emit('}');
};
/**
 * Visit document node.
 */


Compiler.prototype.document = function (node) {
  const doc = '@' + (node.vendor || '') + 'document ' + node.document;
  return this.emit(doc, node.position) + this.emit('{') + this.mapVisit(node.rules) + this.emit('}');
};
/**
 * Visit charset node.
 */


Compiler.prototype.charset = function (node) {
  return this.emit('@charset ' + node.charset + ';', node.position);
};
/**
 * Visit namespace node.
 */


Compiler.prototype.namespace = function (node) {
  return this.emit('@namespace ' + node.namespace + ';', node.position);
};
/**
 * Visit supports node.
 */


Compiler.prototype.supports = function (node) {
  return this.emit('@supports ' + node.supports, node.position) + this.emit('{') + this.mapVisit(node.rules) + this.emit('}');
};
/**
 * Visit keyframes node.
 */


Compiler.prototype.keyframes = function (node) {
  return this.emit('@' + (node.vendor || '') + 'keyframes ' + node.name, node.position) + this.emit('{') + this.mapVisit(node.keyframes) + this.emit('}');
};
/**
 * Visit keyframe node.
 */


Compiler.prototype.keyframe = function (node) {
  const decls = node.declarations;
  return this.emit(node.values.join(','), node.position) + this.emit('{') + this.mapVisit(decls) + this.emit('}');
};
/**
 * Visit page node.
 */


Compiler.prototype.page = function (node) {
  const sel = node.selectors.length ? node.selectors.join(', ') : '';
  return this.emit('@page ' + sel, node.position) + this.emit('{') + this.mapVisit(node.declarations) + this.emit('}');
};
/**
 * Visit font-face node.
 */


Compiler.prototype['font-face'] = function (node) {
  return this.emit('@font-face', node.position) + this.emit('{') + this.mapVisit(node.declarations) + this.emit('}');
};
/**
 * Visit host node.
 */


Compiler.prototype.host = function (node) {
  return this.emit('@host', node.position) + this.emit('{') + this.mapVisit(node.rules) + this.emit('}');
};
/**
 * Visit custom-media node.
 */


Compiler.prototype['custom-media'] = function (node) {
  return this.emit('@custom-media ' + node.name + ' ' + node.media + ';', node.position);
};
/**
 * Visit rule node.
 */


Compiler.prototype.rule = function (node) {
  const decls = node.declarations;

  if (!decls.length) {
    return '';
  }

  return this.emit(node.selectors.join(','), node.position) + this.emit('{') + this.mapVisit(decls) + this.emit('}');
};
/**
 * Visit declaration node.
 */


Compiler.prototype.declaration = function (node) {
  return this.emit(node.property + ':' + node.value, node.position) + this.emit(';');
};
//# sourceMappingURL=compress.js.map

/***/ }),

/***/ "Gg2m":
/*!*******************************************************************************!*\
  !*** ../node_modules/@wordpress/block-editor/build-module/store/constants.js ***!
  \*******************************************************************************/
/*! exports provided: STORE_NAME */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STORE_NAME", function() { return STORE_NAME; });
const STORE_NAME = 'core/block-editor';
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "LdWO":
/*!****************************************************************************************!*\
  !*** ../node_modules/@wordpress/block-editor/build-module/utils/pre-parse-patterns.js ***!
  \****************************************************************************************/
/*! exports provided: usePreParsePatterns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "usePreParsePatterns", function() { return usePreParsePatterns; });
/* harmony import */ var _wordpress_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wordpress/data */ "OgwO");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wordpress/element */ "ptdL");
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store */ "rsyr");
/**
 * WordPress dependencies
 */


/**
 * Internal dependencies
 */



const requestIdleCallback = (() => {
  if (typeof window === 'undefined') {
    return callback => {
      setTimeout(() => callback(Date.now()), 0);
    };
  }

  return window.requestIdleCallback || window.requestAnimationFrame;
})();

const cancelIdleCallback = (() => {
  if (typeof window === 'undefined') {
    return clearTimeout;
  }

  return window.cancelIdleCallback || window.cancelAnimationFrame;
})();

function usePreParsePatterns() {
  const patterns = Object(_wordpress_data__WEBPACK_IMPORTED_MODULE_0__["useSelect"])(_select => _select(_store__WEBPACK_IMPORTED_MODULE_2__["store"]).getSettings().__experimentalBlockPatterns, []);
  Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_1__["useEffect"])(() => {
    if (!(patterns !== null && patterns !== void 0 && patterns.length)) {
      return;
    }

    let handle;
    let index = -1;

    const callback = () => {
      index++;

      if (index >= patterns.length) {
        return;
      }

      Object(_wordpress_data__WEBPACK_IMPORTED_MODULE_0__["select"])(_store__WEBPACK_IMPORTED_MODULE_2__["store"]).__experimentalGetParsedPattern(patterns[index].name);

      handle = requestIdleCallback(callback);
    };

    handle = requestIdleCallback(callback);
    return () => cancelIdleCallback(handle);
  }, [patterns]);
  return null;
}
//# sourceMappingURL=pre-parse-patterns.js.map

/***/ }),

/***/ "PKgW":
/*!*************************************************************************************************************!*\
  !*** ../node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/stringify/compiler.js ***!
  \*************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Adapted from https://github.com/reworkcss/css
// because we needed to remove source map support.

/**
 * Expose `Compiler`.
 */
/* harmony default export */ __webpack_exports__["default"] = (Compiler);
/**
 * Initialize a compiler.
 */

function Compiler(opts) {
  this.options = opts || {};
}
/**
 * Emit `str`
 */


Compiler.prototype.emit = function (str) {
  return str;
};
/**
 * Visit `node`.
 */


Compiler.prototype.visit = function (node) {
  return this[node.type](node);
};
/**
 * Map visit over array of `nodes`, optionally using a `delim`
 */


Compiler.prototype.mapVisit = function (nodes, delim) {
  let buf = '';
  delim = delim || '';

  for (let i = 0, length = nodes.length; i < length; i++) {
    buf += this.visit(nodes[i]);

    if (delim && i < length - 1) {
      buf += this.emit(delim);
    }
  }

  return buf;
};
//# sourceMappingURL=compiler.js.map

/***/ }),

/***/ "QYxo":
/*!*************************************************************************************************************!*\
  !*** ../node_modules/@wordpress/block-editor/build-module/utils/transform-styles/transforms/url-rewrite.js ***!
  \*************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Return `true` if the given path is http/https.
 *
 * @param  {string}  filePath path
 *
 * @return {boolean} is remote path.
 */
function isRemotePath(filePath) {
  return /^(?:https?:)?\/\//.test(filePath);
}
/**
 * Return `true` if the given filePath is an absolute url.
 *
 * @param  {string}  filePath path
 *
 * @return {boolean} is absolute path.
 */


function isAbsolutePath(filePath) {
  return /^\/(?!\/)/.test(filePath);
}
/**
 * Whether or not the url should be inluded.
 *
 * @param  {Object} meta url meta info
 *
 * @return {boolean} is valid.
 */


function isValidURL(meta) {
  // ignore hashes or data uris
  if (meta.value.indexOf('data:') === 0 || meta.value.indexOf('#') === 0) {
    return false;
  }

  if (isAbsolutePath(meta.value)) {
    return false;
  } // do not handle the http/https urls if `includeRemote` is false


  if (isRemotePath(meta.value)) {
    return false;
  }

  return true;
}
/**
 * Get the absolute path of the url, relative to the basePath
 *
 * @param  {string} str          the url
 * @param  {string} baseURL      base URL
 *
 * @return {string}              the full path to the file
 */


function getResourcePath(str, baseURL) {
  return new URL(str, baseURL).toString();
}
/**
 * Process the single `url()` pattern
 *
 * @param  {string} baseURL  the base URL for relative URLs
 * @return {Promise}         the Promise
 */


function processURL(baseURL) {
  return meta => ({ ...meta,
    newUrl: 'url(' + meta.before + meta.quote + getResourcePath(meta.value, baseURL) + meta.quote + meta.after + ')'
  });
}
/**
 * Get all `url()`s, and return the meta info
 *
 * @param  {string} value decl.value
 *
 * @return {Array}        the urls
 */


function getURLs(value) {
  const reg = /url\((\s*)(['"]?)(.+?)\2(\s*)\)/g;
  let match;
  const URLs = [];

  while ((match = reg.exec(value)) !== null) {
    const meta = {
      source: match[0],
      before: match[1],
      quote: match[2],
      value: match[3],
      after: match[4]
    };

    if (isValidURL(meta)) {
      URLs.push(meta);
    }
  }

  return URLs;
}
/**
 * Replace the raw value's `url()` segment to the new value
 *
 * @param  {string} raw  the raw value
 * @param  {Array}  URLs the URLs to replace
 *
 * @return {string}     the new value
 */


function replaceURLs(raw, URLs) {
  URLs.forEach(item => {
    raw = raw.replace(item.source, item.newUrl);
  });
  return raw;
}

const rewrite = rootURL => node => {
  if (node.type === 'declaration') {
    const updatedURLs = getURLs(node.value).map(processURL(rootURL));
    return { ...node,
      value: replaceURLs(node.value, updatedURLs)
    };
  }

  return node;
};

/* harmony default export */ __webpack_exports__["default"] = (rewrite);
//# sourceMappingURL=url-rewrite.js.map

/***/ }),

/***/ "VGZE":
/*!******************************************************************************!*\
  !*** ../node_modules/@wordpress/block-editor/build-module/store/controls.js ***!
  \******************************************************************************/
/*! exports provided: __unstableMarkAutomaticChangeFinalControl, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__unstableMarkAutomaticChangeFinalControl", function() { return __unstableMarkAutomaticChangeFinalControl; });
/* harmony import */ var _wordpress_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wordpress/data */ "OgwO");
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../store */ "rsyr");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */


const __unstableMarkAutomaticChangeFinalControl = function () {
  return {
    type: 'MARK_AUTOMATIC_CHANGE_FINAL_CONTROL'
  };
};
const controls = {
  SLEEP({
    duration
  }) {
    return new Promise(resolve => {
      setTimeout(resolve, duration);
    });
  },

  MARK_AUTOMATIC_CHANGE_FINAL_CONTROL: Object(_wordpress_data__WEBPACK_IMPORTED_MODULE_0__["createRegistryControl"])(registry => () => {
    const {
      requestIdleCallback = callback => setTimeout(callback, 100)
    } = window;
    requestIdleCallback(() => registry.dispatch(_store__WEBPACK_IMPORTED_MODULE_1__["store"]).__unstableMarkAutomaticChangeFinal());
  })
};
/* harmony default export */ __webpack_exports__["default"] = (controls);
//# sourceMappingURL=controls.js.map

/***/ }),

/***/ "W1f9":
/*!*************************************************************************************************************!*\
  !*** ../node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/stringify/identity.js ***!
  \*************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inherits */ "whF7");
/* harmony import */ var inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _compiler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compiler */ "PKgW");
/* eslint-disable @wordpress/no-unused-vars-before-return */
// Adapted from https://github.com/reworkcss/css
// because we needed to remove source map support.

/**
 * External dependencies
 */

/**
 * Internal dependencies
 */


/**
 * Expose compiler.
 */

/* harmony default export */ __webpack_exports__["default"] = (Compiler);
/**
 * Initialize a new `Compiler`.
 */

function Compiler(options) {
  options = options || {};
  _compiler__WEBPACK_IMPORTED_MODULE_1__["default"].call(this, options);
  this.indentation = options.indent;
}
/**
 * Inherit from `Base.prototype`.
 */


inherits__WEBPACK_IMPORTED_MODULE_0___default()(Compiler, _compiler__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * Compile `node`.
 */

Compiler.prototype.compile = function (node) {
  return this.stylesheet(node);
};
/**
 * Visit stylesheet node.
 */


Compiler.prototype.stylesheet = function (node) {
  return this.mapVisit(node.stylesheet.rules, '\n\n');
};
/**
 * Visit comment node.
 */


Compiler.prototype.comment = function (node) {
  return this.emit(this.indent() + '/*' + node.comment + '*/', node.position);
};
/**
 * Visit import node.
 */


Compiler.prototype.import = function (node) {
  return this.emit('@import ' + node.import + ';', node.position);
};
/**
 * Visit media node.
 */


Compiler.prototype.media = function (node) {
  return this.emit('@media ' + node.media, node.position) + this.emit(' {\n' + this.indent(1)) + this.mapVisit(node.rules, '\n\n') + this.emit(this.indent(-1) + '\n}');
};
/**
 * Visit document node.
 */


Compiler.prototype.document = function (node) {
  const doc = '@' + (node.vendor || '') + 'document ' + node.document;
  return this.emit(doc, node.position) + this.emit(' ' + ' {\n' + this.indent(1)) + this.mapVisit(node.rules, '\n\n') + this.emit(this.indent(-1) + '\n}');
};
/**
 * Visit charset node.
 */


Compiler.prototype.charset = function (node) {
  return this.emit('@charset ' + node.charset + ';', node.position);
};
/**
 * Visit namespace node.
 */


Compiler.prototype.namespace = function (node) {
  return this.emit('@namespace ' + node.namespace + ';', node.position);
};
/**
 * Visit supports node.
 */


Compiler.prototype.supports = function (node) {
  return this.emit('@supports ' + node.supports, node.position) + this.emit(' {\n' + this.indent(1)) + this.mapVisit(node.rules, '\n\n') + this.emit(this.indent(-1) + '\n}');
};
/**
 * Visit keyframes node.
 */


Compiler.prototype.keyframes = function (node) {
  return this.emit('@' + (node.vendor || '') + 'keyframes ' + node.name, node.position) + this.emit(' {\n' + this.indent(1)) + this.mapVisit(node.keyframes, '\n') + this.emit(this.indent(-1) + '}');
};
/**
 * Visit keyframe node.
 */


Compiler.prototype.keyframe = function (node) {
  const decls = node.declarations;
  return this.emit(this.indent()) + this.emit(node.values.join(', '), node.position) + this.emit(' {\n' + this.indent(1)) + this.mapVisit(decls, '\n') + this.emit(this.indent(-1) + '\n' + this.indent() + '}\n');
};
/**
 * Visit page node.
 */


Compiler.prototype.page = function (node) {
  const sel = node.selectors.length ? node.selectors.join(', ') + ' ' : '';
  return this.emit('@page ' + sel, node.position) + this.emit('{\n') + this.emit(this.indent(1)) + this.mapVisit(node.declarations, '\n') + this.emit(this.indent(-1)) + this.emit('\n}');
};
/**
 * Visit font-face node.
 */


Compiler.prototype['font-face'] = function (node) {
  return this.emit('@font-face ', node.position) + this.emit('{\n') + this.emit(this.indent(1)) + this.mapVisit(node.declarations, '\n') + this.emit(this.indent(-1)) + this.emit('\n}');
};
/**
 * Visit host node.
 */


Compiler.prototype.host = function (node) {
  return this.emit('@host', node.position) + this.emit(' {\n' + this.indent(1)) + this.mapVisit(node.rules, '\n\n') + this.emit(this.indent(-1) + '\n}');
};
/**
 * Visit custom-media node.
 */


Compiler.prototype['custom-media'] = function (node) {
  return this.emit('@custom-media ' + node.name + ' ' + node.media + ';', node.position);
};
/**
 * Visit rule node.
 */


Compiler.prototype.rule = function (node) {
  const indent = this.indent();
  const decls = node.declarations;

  if (!decls.length) {
    return '';
  }

  return this.emit(node.selectors.map(function (s) {
    return indent + s;
  }).join(',\n'), node.position) + this.emit(' {\n') + this.emit(this.indent(1)) + this.mapVisit(decls, '\n') + this.emit(this.indent(-1)) + this.emit('\n' + this.indent() + '}');
};
/**
 * Visit declaration node.
 */


Compiler.prototype.declaration = function (node) {
  return this.emit(this.indent()) + this.emit(node.property + ': ' + node.value, node.position) + this.emit(';');
};
/**
 * Increase, decrease or return current indentation.
 */


Compiler.prototype.indent = function (level) {
  this.level = this.level || 1;

  if (null !== level) {
    this.level += level;
    return '';
  }

  return Array(this.level).join(this.indentation || '  ');
};
/* eslint-enable @wordpress/no-unused-vars-before-return */
//# sourceMappingURL=identity.js.map

/***/ }),

/***/ "cQaR":
/*!***********************************************************************************************!*\
  !*** ../node_modules/@wordpress/block-editor/build-module/utils/transform-styles/traverse.js ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var traverse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! traverse */ "4gDj");
/* harmony import */ var traverse__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(traverse__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ast */ "saH8");
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */



function traverseCSS(css, callback) {
  try {
    const parsed = Object(_ast__WEBPACK_IMPORTED_MODULE_1__["parse"])(css);
    const updated = traverse__WEBPACK_IMPORTED_MODULE_0___default.a.map(parsed, function (node) {
      if (!node) {
        return node;
      }

      const updatedNode = callback(node);
      return this.update(updatedNode);
    });
    return Object(_ast__WEBPACK_IMPORTED_MODULE_1__["stringify"])(updated);
  } catch (err) {
    // eslint-disable-next-line no-console
    console.warn('Error while traversing the CSS: ' + err);
    return null;
  }
}

/* harmony default export */ __webpack_exports__["default"] = (traverseCSS);
//# sourceMappingURL=traverse.js.map

/***/ }),

/***/ "cUWY":
/*!***************************************************************************!*\
  !*** ../node_modules/@wordpress/block-editor/build-module/utils/theme.js ***!
  \***************************************************************************/
/*! exports provided: validateThemeColors, validateThemeGradients */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateThemeColors", function() { return validateThemeColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateThemeGradients", function() { return validateThemeGradients; });
/* harmony import */ var _store_defaults__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../store/defaults */ "0O9v");
/**
 * Internal dependencies
 */

/**
 * Given an array of theme colors checks colors for validity
 *
 * @param {Array}   colors  The array of theme colors
 *
 * @return {Array} The array of valid theme colors or the default colors
 */

function validateThemeColors(colors) {
  if (colors === undefined) {
    colors = _store_defaults__WEBPACK_IMPORTED_MODULE_0__["SETTINGS_DEFAULTS"].colors;
  } else {
    const validColors = colors.filter(c => c.color);

    if (validColors.length === 0) {
      colors = _store_defaults__WEBPACK_IMPORTED_MODULE_0__["SETTINGS_DEFAULTS"].colors;
    } else if (validColors.length < colors.length) {
      // Filter out invalid colors
      colors = validColors;
    }
  }

  return colors;
}
/**
 * Given an array of theme gradients checks gradients for validity
 *
 * @param {Array}   gradients  The array of theme gradients
 *
 * @return {Array} The array of valid theme gradients or the default gradients
 */

function validateThemeGradients(gradients) {
  if (gradients === undefined) {
    gradients = _store_defaults__WEBPACK_IMPORTED_MODULE_0__["SETTINGS_DEFAULTS"].gradients;
  } else {
    const validGradients = gradients.filter(c => c.gradient);

    if (validGradients.length === 0) {
      gradients = _store_defaults__WEBPACK_IMPORTED_MODULE_0__["SETTINGS_DEFAULTS"].gradients;
    } else if (validGradients.length < gradients.length) {
      // Filter out invalid gradients
      gradients = validGradients;
    }
  }

  return gradients;
}
//# sourceMappingURL=theme.js.map

/***/ }),

/***/ "fpEj":
/*!**********************************************************************************************************!*\
  !*** ../node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/stringify/index.js ***!
  \**********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _compress__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compress */ "Gay7");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./identity */ "W1f9");
// Adapted from https://github.com/reworkcss/css
// because we needed to remove source map support.

/**
 * Internal dependencies
 */


/**
 * Stringfy the given AST `node`.
 *
 * Options:
 *
 *  - `compress` space-optimized output
 *  - `sourcemap` return an object with `.code` and `.map`
 *
 * @param {Object} node
 * @param {Object} [options]
 * @return {string}
 */

/* harmony default export */ __webpack_exports__["default"] = (function (node, options) {
  options = options || {};
  const compiler = options.compress ? new _compress__WEBPACK_IMPORTED_MODULE_0__["default"](options) : new _identity__WEBPACK_IMPORTED_MODULE_1__["default"](options);
  const code = compiler.compile(node);
  return code;
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "l0ML":
/*!*******************************************************************************!*\
  !*** ../node_modules/@wordpress/block-editor/build-module/store/selectors.js ***!
  \*******************************************************************************/
/*! exports provided: getBlockName, isBlockValid, getBlockAttributes, getBlock, __unstableGetBlockWithoutInnerBlocks, getBlocks, __unstableGetBlockWithBlockTree, __unstableGetBlockTree, __unstableGetClientIdWithClientIdsTree, __unstableGetClientIdsTree, getClientIdsOfDescendants, getClientIdsWithDescendants, getGlobalBlockCount, getBlocksByClientId, getBlockCount, getSelectionStart, getSelectionEnd, getBlockSelectionStart, getBlockSelectionEnd, getSelectedBlockCount, hasSelectedBlock, getSelectedBlockClientId, getSelectedBlock, getBlockRootClientId, getBlockParents, getBlockParentsByBlockName, getBlockHierarchyRootClientId, getLowestCommonAncestorWithSelectedBlock, getAdjacentBlockClientId, getPreviousBlockClientId, getNextBlockClientId, getSelectedBlocksInitialCaretPosition, getSelectedBlockClientIds, getMultiSelectedBlockClientIds, getMultiSelectedBlocks, getFirstMultiSelectedBlockClientId, getLastMultiSelectedBlockClientId, isFirstMultiSelectedBlock, isBlockMultiSelected, isAncestorMultiSelected, getMultiSelectedBlocksStartClientId, getMultiSelectedBlocksEndClientId, getBlockOrder, getBlockIndex, isBlockSelected, hasSelectedInnerBlock, isBlockWithinSelection, hasMultiSelection, isMultiSelecting, isSelectionEnabled, getBlockMode, isTyping, isDraggingBlocks, getDraggedBlockClientIds, isBlockBeingDragged, isAncestorBeingDragged, isCaretWithinFormattedText, getBlockInsertionPoint, isBlockInsertionPointVisible, isValidTemplate, getTemplate, getTemplateLock, canInsertBlockType, canInsertBlocks, getInserterItems, getBlockTransformItems, hasInserterItems, __experimentalGetAllowedBlocks, __experimentalGetParsedPattern, __experimentalGetAllowedPatterns, __experimentalGetPatternsByBlockTypes, __experimentalGetPatternTransformItems, getBlockListSettings, getSettings, isLastBlockChangePersistent, __experimentalGetBlockListSettingsForBlocks, __experimentalGetParsedReusableBlock, __experimentalGetReusableBlockTitle, __unstableIsLastBlockChangeIgnored, __experimentalGetLastBlockAttributeChanges, isNavigationMode, hasBlockMovingClientId, didAutomaticChange, isBlockHighlighted, areInnerBlocksControlled, __experimentalGetActiveBlockIdByBlockNames, wasBlockJustInserted */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBlockName", function() { return getBlockName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBlockValid", function() { return isBlockValid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBlockAttributes", function() { return getBlockAttributes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBlock", function() { return getBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__unstableGetBlockWithoutInnerBlocks", function() { return __unstableGetBlockWithoutInnerBlocks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBlocks", function() { return getBlocks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__unstableGetBlockWithBlockTree", function() { return __unstableGetBlockWithBlockTree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__unstableGetBlockTree", function() { return __unstableGetBlockTree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__unstableGetClientIdWithClientIdsTree", function() { return __unstableGetClientIdWithClientIdsTree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__unstableGetClientIdsTree", function() { return __unstableGetClientIdsTree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getClientIdsOfDescendants", function() { return getClientIdsOfDescendants; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getClientIdsWithDescendants", function() { return getClientIdsWithDescendants; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGlobalBlockCount", function() { return getGlobalBlockCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBlocksByClientId", function() { return getBlocksByClientId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBlockCount", function() { return getBlockCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSelectionStart", function() { return getSelectionStart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSelectionEnd", function() { return getSelectionEnd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBlockSelectionStart", function() { return getBlockSelectionStart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBlockSelectionEnd", function() { return getBlockSelectionEnd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSelectedBlockCount", function() { return getSelectedBlockCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasSelectedBlock", function() { return hasSelectedBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSelectedBlockClientId", function() { return getSelectedBlockClientId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSelectedBlock", function() { return getSelectedBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBlockRootClientId", function() { return getBlockRootClientId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBlockParents", function() { return getBlockParents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBlockParentsByBlockName", function() { return getBlockParentsByBlockName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBlockHierarchyRootClientId", function() { return getBlockHierarchyRootClientId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLowestCommonAncestorWithSelectedBlock", function() { return getLowestCommonAncestorWithSelectedBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAdjacentBlockClientId", function() { return getAdjacentBlockClientId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPreviousBlockClientId", function() { return getPreviousBlockClientId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNextBlockClientId", function() { return getNextBlockClientId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSelectedBlocksInitialCaretPosition", function() { return getSelectedBlocksInitialCaretPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSelectedBlockClientIds", function() { return getSelectedBlockClientIds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMultiSelectedBlockClientIds", function() { return getMultiSelectedBlockClientIds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMultiSelectedBlocks", function() { return getMultiSelectedBlocks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFirstMultiSelectedBlockClientId", function() { return getFirstMultiSelectedBlockClientId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLastMultiSelectedBlockClientId", function() { return getLastMultiSelectedBlockClientId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFirstMultiSelectedBlock", function() { return isFirstMultiSelectedBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBlockMultiSelected", function() { return isBlockMultiSelected; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAncestorMultiSelected", function() { return isAncestorMultiSelected; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMultiSelectedBlocksStartClientId", function() { return getMultiSelectedBlocksStartClientId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMultiSelectedBlocksEndClientId", function() { return getMultiSelectedBlocksEndClientId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBlockOrder", function() { return getBlockOrder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBlockIndex", function() { return getBlockIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBlockSelected", function() { return isBlockSelected; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasSelectedInnerBlock", function() { return hasSelectedInnerBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBlockWithinSelection", function() { return isBlockWithinSelection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasMultiSelection", function() { return hasMultiSelection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMultiSelecting", function() { return isMultiSelecting; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSelectionEnabled", function() { return isSelectionEnabled; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBlockMode", function() { return getBlockMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTyping", function() { return isTyping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDraggingBlocks", function() { return isDraggingBlocks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDraggedBlockClientIds", function() { return getDraggedBlockClientIds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBlockBeingDragged", function() { return isBlockBeingDragged; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAncestorBeingDragged", function() { return isAncestorBeingDragged; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isCaretWithinFormattedText", function() { return isCaretWithinFormattedText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBlockInsertionPoint", function() { return getBlockInsertionPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBlockInsertionPointVisible", function() { return isBlockInsertionPointVisible; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidTemplate", function() { return isValidTemplate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTemplate", function() { return getTemplate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTemplateLock", function() { return getTemplateLock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "canInsertBlockType", function() { return canInsertBlockType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "canInsertBlocks", function() { return canInsertBlocks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getInserterItems", function() { return getInserterItems; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBlockTransformItems", function() { return getBlockTransformItems; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasInserterItems", function() { return hasInserterItems; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__experimentalGetAllowedBlocks", function() { return __experimentalGetAllowedBlocks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__experimentalGetParsedPattern", function() { return __experimentalGetParsedPattern; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__experimentalGetAllowedPatterns", function() { return __experimentalGetAllowedPatterns; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__experimentalGetPatternsByBlockTypes", function() { return __experimentalGetPatternsByBlockTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__experimentalGetPatternTransformItems", function() { return __experimentalGetPatternTransformItems; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBlockListSettings", function() { return getBlockListSettings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSettings", function() { return getSettings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isLastBlockChangePersistent", function() { return isLastBlockChangePersistent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__experimentalGetBlockListSettingsForBlocks", function() { return __experimentalGetBlockListSettingsForBlocks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__experimentalGetParsedReusableBlock", function() { return __experimentalGetParsedReusableBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__experimentalGetReusableBlockTitle", function() { return __experimentalGetReusableBlockTitle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__unstableIsLastBlockChangeIgnored", function() { return __unstableIsLastBlockChangeIgnored; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__experimentalGetLastBlockAttributeChanges", function() { return __experimentalGetLastBlockAttributeChanges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNavigationMode", function() { return isNavigationMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasBlockMovingClientId", function() { return hasBlockMovingClientId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "didAutomaticChange", function() { return didAutomaticChange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBlockHighlighted", function() { return isBlockHighlighted; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areInnerBlocksControlled", function() { return areInnerBlocksControlled; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__experimentalGetActiveBlockIdByBlockNames", function() { return __experimentalGetActiveBlockIdByBlockNames; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wasBlockJustInserted", function() { return wasBlockJustInserted; });
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wordpress/element */ "ptdL");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "9va6");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var rememo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rememo */ "qkku");
/* harmony import */ var _wordpress_blocks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @wordpress/blocks */ "f/Qs");
/* harmony import */ var _wordpress_components__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @wordpress/components */ "ipCc");


/**
 * External dependencies
 */


/**
 * WordPress dependencies
 */




/**
 * A block selection object.
 *
 * @typedef {Object} WPBlockSelection
 *
 * @property {string} clientId     A block client ID.
 * @property {string} attributeKey A block attribute key.
 * @property {number} offset       An attribute value offset, based on the rich
 *                                 text value. See `wp.richText.create`.
 */
// Module constants

const MILLISECONDS_PER_HOUR = 3600 * 1000;
const MILLISECONDS_PER_DAY = 24 * 3600 * 1000;
const MILLISECONDS_PER_WEEK = 7 * 24 * 3600 * 1000;
const templateIcon = Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_components__WEBPACK_IMPORTED_MODULE_4__["SVG"], {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_components__WEBPACK_IMPORTED_MODULE_4__["Rect"], {
  x: "0",
  fill: "none",
  width: "24",
  height: "24"
}), Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_components__WEBPACK_IMPORTED_MODULE_4__["G"], null, Object(_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["createElement"])(_wordpress_components__WEBPACK_IMPORTED_MODULE_4__["Path"], {
  d: "M19 3H5c-1.105 0-2 .895-2 2v14c0 1.105.895 2 2 2h14c1.105 0 2-.895 2-2V5c0-1.105-.895-2-2-2zM6 6h5v5H6V6zm4.5 13C9.12 19 8 17.88 8 16.5S9.12 14 10.5 14s2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5zm3-6l3-5 3 5h-6z"
})));
/**
 * Shared reference to an empty array for cases where it is important to avoid
 * returning a new array reference on every invocation, as in a connected or
 * other pure component which performs `shouldComponentUpdate` check on props.
 * This should be used as a last resort, since the normalized data should be
 * maintained by the reducer result in state.
 *
 * @type {Array}
 */

const EMPTY_ARRAY = [];
/**
 * Returns a block's name given its client ID, or null if no block exists with
 * the client ID.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {string} Block name.
 */

function getBlockName(state, clientId) {
  const block = state.blocks.byClientId[clientId];
  const socialLinkName = 'core/social-link';

  if (_wordpress_element__WEBPACK_IMPORTED_MODULE_0__["Platform"].OS !== 'web' && (block === null || block === void 0 ? void 0 : block.name) === socialLinkName) {
    const attributes = state.blocks.attributes[clientId];
    const {
      service
    } = attributes;
    return service ? `${socialLinkName}-${service}` : socialLinkName;
  }

  return block ? block.name : null;
}
/**
 * Returns whether a block is valid or not.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Is Valid.
 */

function isBlockValid(state, clientId) {
  const block = state.blocks.byClientId[clientId];
  return !!block && block.isValid;
}
/**
 * Returns a block's attributes given its client ID, or null if no block exists with
 * the client ID.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {Object?} Block attributes.
 */

function getBlockAttributes(state, clientId) {
  const block = state.blocks.byClientId[clientId];

  if (!block) {
    return null;
  }

  return state.blocks.attributes[clientId];
}
/**
 * Returns a block given its client ID. This is a parsed copy of the block,
 * containing its `blockName`, `clientId`, and current `attributes` state. This
 * is not the block's registration settings, which must be retrieved from the
 * blocks module registration store.
 *
 * getBlock recurses through its inner blocks until all its children blocks have
 * been retrieved. Note that getBlock will not return the child inner blocks of
 * an inner block controller. This is because an inner block controller syncs
 * itself with its own entity, and should therefore not be included with the
 * blocks of a different entity. For example, say you call `getBlocks( TP )` to
 * get the blocks of a template part. If another template part is a child of TP,
 * then the nested template part's child blocks will not be returned. This way,
 * the template block itself is considered part of the parent, but the children
 * are not.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {Object} Parsed block object.
 */

const getBlock = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])((state, clientId) => {
  const block = state.blocks.byClientId[clientId];

  if (!block) {
    return null;
  }

  return { ...block,
    attributes: getBlockAttributes(state, clientId),
    innerBlocks: areInnerBlocksControlled(state, clientId) ? EMPTY_ARRAY : getBlocks(state, clientId)
  };
}, (state, clientId) => [// Normally, we'd have both `getBlockAttributes` dependencies and
// `getBlocks` (children) dependencies here but for performance reasons
// we use a denormalized cache key computed in the reducer that takes both
// the attributes and inner blocks into account. The value of the cache key
// is being changed whenever one of these dependencies is out of date.
state.blocks.cache[clientId]]);
const __unstableGetBlockWithoutInnerBlocks = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])((state, clientId) => {
  const block = state.blocks.byClientId[clientId];

  if (!block) {
    return null;
  }

  return { ...block,
    attributes: getBlockAttributes(state, clientId)
  };
}, (state, clientId) => [state.blocks.byClientId[clientId], state.blocks.attributes[clientId]]);
/**
 * Returns all block objects for the current post being edited as an array in
 * the order they appear in the post. Note that this will exclude child blocks
 * of nested inner block controllers.
 *
 * Note: It's important to memoize this selector to avoid return a new instance
 * on each call. We use the block cache state for each top-level block of the
 * given clientID. This way, the selector only refreshes on changes to blocks
 * associated with the given entity, and does not refresh when changes are made
 * to blocks which are part of different inner block controllers.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Object[]} Post blocks.
 */

const getBlocks = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])((state, rootClientId) => {
  return Object(lodash__WEBPACK_IMPORTED_MODULE_1__["map"])(getBlockOrder(state, rootClientId), clientId => getBlock(state, clientId));
}, (state, rootClientId) => Object(lodash__WEBPACK_IMPORTED_MODULE_1__["map"])(state.blocks.order[rootClientId || ''], id => state.blocks.cache[id]));
/**
 * Similar to getBlock, except it will include the entire nested block tree as
 * inner blocks. The normal getBlock selector will exclude sections of the block
 * tree which belong to different entities.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Client ID of the block to get.
 *
 * @return {Object} The block with all
 */

const __unstableGetBlockWithBlockTree = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])((state, clientId) => {
  const block = state.blocks.byClientId[clientId];

  if (!block) {
    return null;
  }

  return { ...block,
    attributes: getBlockAttributes(state, clientId),
    innerBlocks: __unstableGetBlockTree(state, clientId)
  };
}, state => [state.blocks.byClientId, state.blocks.order, state.blocks.attributes]);
/**
 * Similar to getBlocks, except this selector returns the entire block tree
 * represented in the block-editor store from the given root regardless of any
 * inner block controllers.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Object[]} Post blocks.
 */

const __unstableGetBlockTree = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])((state, rootClientId = '') => Object(lodash__WEBPACK_IMPORTED_MODULE_1__["map"])(getBlockOrder(state, rootClientId), clientId => __unstableGetBlockWithBlockTree(state, clientId)), state => [state.blocks.byClientId, state.blocks.order, state.blocks.attributes]);
/**
 * Returns a stripped down block object containing only its client ID,
 * and its inner blocks' client IDs.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Client ID of the block to get.
 *
 * @return {Object} Client IDs of the post blocks.
 */

const __unstableGetClientIdWithClientIdsTree = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])((state, clientId) => ({
  clientId,
  innerBlocks: __unstableGetClientIdsTree(state, clientId)
}), state => [state.blocks.order]);
/**
 * Returns the block tree represented in the block-editor store from the
 * given root, consisting of stripped down block objects containing only
 * their client IDs, and their inner blocks' client IDs.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Object[]} Client IDs of the post blocks.
 */

const __unstableGetClientIdsTree = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])((state, rootClientId = '') => Object(lodash__WEBPACK_IMPORTED_MODULE_1__["map"])(getBlockOrder(state, rootClientId), clientId => __unstableGetClientIdWithClientIdsTree(state, clientId)), state => [state.blocks.order]);
/**
 * Returns an array containing the clientIds of all descendants
 * of the blocks given.
 *
 * @param {Object} state Global application state.
 * @param {Array} clientIds Array of blocks to inspect.
 *
 * @return {Array} ids of descendants.
 */

const getClientIdsOfDescendants = (state, clientIds) => Object(lodash__WEBPACK_IMPORTED_MODULE_1__["flatMap"])(clientIds, clientId => {
  const descendants = getBlockOrder(state, clientId);
  return [...descendants, ...getClientIdsOfDescendants(state, descendants)];
});
/**
 * Returns an array containing the clientIds of the top-level blocks
 * and their descendants of any depth (for nested blocks).
 *
 * @param {Object} state Global application state.
 *
 * @return {Array} ids of top-level and descendant blocks.
 */

const getClientIdsWithDescendants = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])(state => {
  const topLevelIds = getBlockOrder(state);
  return [...topLevelIds, ...getClientIdsOfDescendants(state, topLevelIds)];
}, state => [state.blocks.order]);
/**
 * Returns the total number of blocks, or the total number of blocks with a specific name in a post.
 * The number returned includes nested blocks.
 *
 * @param {Object}  state     Global application state.
 * @param {?string} blockName Optional block name, if specified only blocks of that type will be counted.
 *
 * @return {number} Number of blocks in the post, or number of blocks with name equal to blockName.
 */

const getGlobalBlockCount = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])((state, blockName) => {
  const clientIds = getClientIdsWithDescendants(state);

  if (!blockName) {
    return clientIds.length;
  }

  return Object(lodash__WEBPACK_IMPORTED_MODULE_1__["reduce"])(clientIds, (accumulator, clientId) => {
    const block = state.blocks.byClientId[clientId];
    return block.name === blockName ? accumulator + 1 : accumulator;
  }, 0);
}, state => [state.blocks.order, state.blocks.byClientId]);
/**
 * Given an array of block client IDs, returns the corresponding array of block
 * objects.
 *
 * @param {Object}   state     Editor state.
 * @param {string[]} clientIds Client IDs for which blocks are to be returned.
 *
 * @return {WPBlock[]} Block objects.
 */

const getBlocksByClientId = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])((state, clientIds) => Object(lodash__WEBPACK_IMPORTED_MODULE_1__["map"])(Object(lodash__WEBPACK_IMPORTED_MODULE_1__["castArray"])(clientIds), clientId => getBlock(state, clientId)), state => [state.blocks.byClientId, state.blocks.order, state.blocks.attributes]);
/**
 * Returns the number of blocks currently present in the post.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {number} Number of blocks in the post.
 */

function getBlockCount(state, rootClientId) {
  return getBlockOrder(state, rootClientId).length;
}
/**
 * Returns the current selection start block client ID, attribute key and text
 * offset.
 *
 * @param {Object} state Block editor state.
 *
 * @return {WPBlockSelection} Selection start information.
 */

function getSelectionStart(state) {
  return state.selection.selectionStart;
}
/**
 * Returns the current selection end block client ID, attribute key and text
 * offset.
 *
 * @param {Object} state Block editor state.
 *
 * @return {WPBlockSelection} Selection end information.
 */

function getSelectionEnd(state) {
  return state.selection.selectionEnd;
}
/**
 * Returns the current block selection start. This value may be null, and it
 * may represent either a singular block selection or multi-selection start.
 * A selection is singular if its start and end match.
 *
 * @param {Object} state Global application state.
 *
 * @return {?string} Client ID of block selection start.
 */

function getBlockSelectionStart(state) {
  return state.selection.selectionStart.clientId;
}
/**
 * Returns the current block selection end. This value may be null, and it
 * may represent either a singular block selection or multi-selection end.
 * A selection is singular if its start and end match.
 *
 * @param {Object} state Global application state.
 *
 * @return {?string} Client ID of block selection end.
 */

function getBlockSelectionEnd(state) {
  return state.selection.selectionEnd.clientId;
}
/**
 * Returns the number of blocks currently selected in the post.
 *
 * @param {Object} state Global application state.
 *
 * @return {number} Number of blocks selected in the post.
 */

function getSelectedBlockCount(state) {
  const multiSelectedBlockCount = getMultiSelectedBlockClientIds(state).length;

  if (multiSelectedBlockCount) {
    return multiSelectedBlockCount;
  }

  return state.selection.selectionStart.clientId ? 1 : 0;
}
/**
 * Returns true if there is a single selected block, or false otherwise.
 *
 * @param {Object} state Editor state.
 *
 * @return {boolean} Whether a single block is selected.
 */

function hasSelectedBlock(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;
  return !!selectionStart.clientId && selectionStart.clientId === selectionEnd.clientId;
}
/**
 * Returns the currently selected block client ID, or null if there is no
 * selected block.
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} Selected block client ID.
 */

function getSelectedBlockClientId(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;
  const {
    clientId
  } = selectionStart;

  if (!clientId || clientId !== selectionEnd.clientId) {
    return null;
  }

  return clientId;
}
/**
 * Returns the currently selected block, or null if there is no selected block.
 *
 * @param {Object} state Global application state.
 *
 * @return {?Object} Selected block.
 */

function getSelectedBlock(state) {
  const clientId = getSelectedBlockClientId(state);
  return clientId ? getBlock(state, clientId) : null;
}
/**
 * Given a block client ID, returns the root block from which the block is
 * nested, an empty string for top-level blocks, or null if the block does not
 * exist.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block from which to find root client ID.
 *
 * @return {?string} Root client ID, if exists
 */

function getBlockRootClientId(state, clientId) {
  return state.blocks.parents[clientId] !== undefined ? state.blocks.parents[clientId] : null;
}
/**
 * Given a block client ID, returns the list of all its parents from top to bottom.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block from which to find root client ID.
 * @param {boolean} ascending Order results from bottom to top (true) or top to bottom (false).
 *
 * @return {Array} ClientIDs of the parent blocks.
 */

const getBlockParents = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])((state, clientId, ascending = false) => {
  const parents = [];
  let current = clientId;

  while (!!state.blocks.parents[current]) {
    current = state.blocks.parents[current];
    parents.push(current);
  }

  return ascending ? parents : parents.reverse();
}, state => [state.blocks.parents]);
/**
 * Given a block client ID and a block name, returns the list of all its parents
 * from top to bottom, filtered by the given name(s). For example, if passed
 * 'core/group' as the blockName, it will only return parents which are group
 * blocks. If passed `[ 'core/group', 'core/cover']`, as the blockName, it will
 * return parents which are group blocks and parents which are cover blocks.
 *
 * @param {Object}          state     Editor state.
 * @param {string}          clientId  Block from which to find root client ID.
 * @param {string|string[]} blockName Block name(s) to filter.
 * @param {boolean}         ascending Order results from bottom to top (true) or top to bottom (false).
 *
 * @return {Array} ClientIDs of the parent blocks.
 */

const getBlockParentsByBlockName = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])((state, clientId, blockName, ascending = false) => {
  const parents = getBlockParents(state, clientId, ascending);
  return Object(lodash__WEBPACK_IMPORTED_MODULE_1__["map"])(Object(lodash__WEBPACK_IMPORTED_MODULE_1__["filter"])(Object(lodash__WEBPACK_IMPORTED_MODULE_1__["map"])(parents, id => ({
    id,
    name: getBlockName(state, id)
  })), ({
    name
  }) => {
    if (Array.isArray(blockName)) {
      return blockName.includes(name);
    }

    return name === blockName;
  }), ({
    id
  }) => id);
}, state => [state.blocks.parents]);
/**
 * Given a block client ID, returns the root of the hierarchy from which the block is nested, return the block itself for root level blocks.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block from which to find root client ID.
 *
 * @return {string} Root client ID
 */

function getBlockHierarchyRootClientId(state, clientId) {
  let current = clientId;
  let parent;

  do {
    parent = current;
    current = state.blocks.parents[current];
  } while (current);

  return parent;
}
/**
 * Given a block client ID, returns the lowest common ancestor with selected client ID.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block from which to find common ancestor client ID.
 *
 * @return {string} Common ancestor client ID or undefined
 */

function getLowestCommonAncestorWithSelectedBlock(state, clientId) {
  const selectedId = getSelectedBlockClientId(state);
  const clientParents = [...getBlockParents(state, clientId), clientId];
  const selectedParents = [...getBlockParents(state, selectedId), selectedId];
  let lowestCommonAncestor;
  const maxDepth = Math.min(clientParents.length, selectedParents.length);

  for (let index = 0; index < maxDepth; index++) {
    if (clientParents[index] === selectedParents[index]) {
      lowestCommonAncestor = clientParents[index];
    } else {
      break;
    }
  }

  return lowestCommonAncestor;
}
/**
 * Returns the client ID of the block adjacent one at the given reference
 * startClientId and modifier directionality. Defaults start startClientId to
 * the selected block, and direction as next block. Returns null if there is no
 * adjacent block.
 *
 * @param {Object}  state         Editor state.
 * @param {?string} startClientId Optional client ID of block from which to
 *                                search.
 * @param {?number} modifier      Directionality multiplier (1 next, -1
 *                                previous).
 *
 * @return {?string} Return the client ID of the block, or null if none exists.
 */

function getAdjacentBlockClientId(state, startClientId, modifier = 1) {
  // Default to selected block.
  if (startClientId === undefined) {
    startClientId = getSelectedBlockClientId(state);
  } // Try multi-selection starting at extent based on modifier.


  if (startClientId === undefined) {
    if (modifier < 0) {
      startClientId = getFirstMultiSelectedBlockClientId(state);
    } else {
      startClientId = getLastMultiSelectedBlockClientId(state);
    }
  } // Validate working start client ID.


  if (!startClientId) {
    return null;
  } // Retrieve start block root client ID, being careful to allow the falsey
  // empty string top-level root by explicitly testing against null.


  const rootClientId = getBlockRootClientId(state, startClientId);

  if (rootClientId === null) {
    return null;
  }

  const {
    order
  } = state.blocks;
  const orderSet = order[rootClientId];
  const index = orderSet.indexOf(startClientId);
  const nextIndex = index + 1 * modifier; // Block was first in set and we're attempting to get previous.

  if (nextIndex < 0) {
    return null;
  } // Block was last in set and we're attempting to get next.


  if (nextIndex === orderSet.length) {
    return null;
  } // Assume incremented index is within the set.


  return orderSet[nextIndex];
}
/**
 * Returns the previous block's client ID from the given reference start ID.
 * Defaults start to the selected block. Returns null if there is no previous
 * block.
 *
 * @param {Object}  state         Editor state.
 * @param {?string} startClientId Optional client ID of block from which to
 *                                search.
 *
 * @return {?string} Adjacent block's client ID, or null if none exists.
 */

function getPreviousBlockClientId(state, startClientId) {
  return getAdjacentBlockClientId(state, startClientId, -1);
}
/**
 * Returns the next block's client ID from the given reference start ID.
 * Defaults start to the selected block. Returns null if there is no next
 * block.
 *
 * @param {Object}  state         Editor state.
 * @param {?string} startClientId Optional client ID of block from which to
 *                                search.
 *
 * @return {?string} Adjacent block's client ID, or null if none exists.
 */

function getNextBlockClientId(state, startClientId) {
  return getAdjacentBlockClientId(state, startClientId, 1);
}
/**
 * Returns the initial caret position for the selected block.
 * This position is to used to position the caret properly when the selected block changes.
 * If the current block is not a RichText, having initial position set to 0 means "focus block"
 *
 * @param {Object} state Global application state.
 *
 * @return {0|-1|null} Initial position.
 */

function getSelectedBlocksInitialCaretPosition(state) {
  return state.initialPosition;
}
/**
 * Returns the current selection set of block client IDs (multiselection or single selection).
 *
 * @param {Object} state Editor state.
 *
 * @return {Array} Multi-selected block client IDs.
 */

const getSelectedBlockClientIds = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])(state => {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;

  if (selectionStart.clientId === undefined || selectionEnd.clientId === undefined) {
    return EMPTY_ARRAY;
  }

  if (selectionStart.clientId === selectionEnd.clientId) {
    return [selectionStart.clientId];
  } // Retrieve root client ID to aid in retrieving relevant nested block
  // order, being careful to allow the falsey empty string top-level root
  // by explicitly testing against null.


  const rootClientId = getBlockRootClientId(state, selectionStart.clientId);

  if (rootClientId === null) {
    return EMPTY_ARRAY;
  }

  const blockOrder = getBlockOrder(state, rootClientId);
  const startIndex = blockOrder.indexOf(selectionStart.clientId);
  const endIndex = blockOrder.indexOf(selectionEnd.clientId);

  if (startIndex > endIndex) {
    return blockOrder.slice(endIndex, startIndex + 1);
  }

  return blockOrder.slice(startIndex, endIndex + 1);
}, state => [state.blocks.order, state.selection.selectionStart.clientId, state.selection.selectionEnd.clientId]);
/**
 * Returns the current multi-selection set of block client IDs, or an empty
 * array if there is no multi-selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {Array} Multi-selected block client IDs.
 */

function getMultiSelectedBlockClientIds(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;

  if (selectionStart.clientId === selectionEnd.clientId) {
    return EMPTY_ARRAY;
  }

  return getSelectedBlockClientIds(state);
}
/**
 * Returns the current multi-selection set of blocks, or an empty array if
 * there is no multi-selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {Array} Multi-selected block objects.
 */

const getMultiSelectedBlocks = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])(state => {
  const multiSelectedBlockClientIds = getMultiSelectedBlockClientIds(state);

  if (!multiSelectedBlockClientIds.length) {
    return EMPTY_ARRAY;
  }

  return multiSelectedBlockClientIds.map(clientId => getBlock(state, clientId));
}, state => [...getSelectedBlockClientIds.getDependants(state), state.blocks.byClientId, state.blocks.order, state.blocks.attributes]);
/**
 * Returns the client ID of the first block in the multi-selection set, or null
 * if there is no multi-selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} First block client ID in the multi-selection set.
 */

function getFirstMultiSelectedBlockClientId(state) {
  return Object(lodash__WEBPACK_IMPORTED_MODULE_1__["first"])(getMultiSelectedBlockClientIds(state)) || null;
}
/**
 * Returns the client ID of the last block in the multi-selection set, or null
 * if there is no multi-selection.
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} Last block client ID in the multi-selection set.
 */

function getLastMultiSelectedBlockClientId(state) {
  return Object(lodash__WEBPACK_IMPORTED_MODULE_1__["last"])(getMultiSelectedBlockClientIds(state)) || null;
}
/**
 * Returns true if a multi-selection exists, and the block corresponding to the
 * specified client ID is the first block of the multi-selection set, or false
 * otherwise.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether block is first in multi-selection.
 */

function isFirstMultiSelectedBlock(state, clientId) {
  return getFirstMultiSelectedBlockClientId(state) === clientId;
}
/**
 * Returns true if the client ID occurs within the block multi-selection, or
 * false otherwise.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether block is in multi-selection set.
 */

function isBlockMultiSelected(state, clientId) {
  return getMultiSelectedBlockClientIds(state).indexOf(clientId) !== -1;
}
/**
 * Returns true if an ancestor of the block is multi-selected, or false
 * otherwise.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether an ancestor of the block is in multi-selection
 *                   set.
 */

const isAncestorMultiSelected = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])((state, clientId) => {
  let ancestorClientId = clientId;
  let isMultiSelected = false;

  while (ancestorClientId && !isMultiSelected) {
    ancestorClientId = getBlockRootClientId(state, ancestorClientId);
    isMultiSelected = isBlockMultiSelected(state, ancestorClientId);
  }

  return isMultiSelected;
}, state => [state.blocks.order, state.selection.selectionStart.clientId, state.selection.selectionEnd.clientId]);
/**
 * Returns the client ID of the block which begins the multi-selection set, or
 * null if there is no multi-selection.
 *
 * This is not necessarily the first client ID in the selection.
 *
 * @see getFirstMultiSelectedBlockClientId
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} Client ID of block beginning multi-selection.
 */

function getMultiSelectedBlocksStartClientId(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;

  if (selectionStart.clientId === selectionEnd.clientId) {
    return null;
  }

  return selectionStart.clientId || null;
}
/**
 * Returns the client ID of the block which ends the multi-selection set, or
 * null if there is no multi-selection.
 *
 * This is not necessarily the last client ID in the selection.
 *
 * @see getLastMultiSelectedBlockClientId
 *
 * @param {Object} state Editor state.
 *
 * @return {?string} Client ID of block ending multi-selection.
 */

function getMultiSelectedBlocksEndClientId(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;

  if (selectionStart.clientId === selectionEnd.clientId) {
    return null;
  }

  return selectionEnd.clientId || null;
}
/**
 * Returns an array containing all block client IDs in the editor in the order
 * they appear. Optionally accepts a root client ID of the block list for which
 * the order should be returned, defaulting to the top-level block order.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Array} Ordered client IDs of editor blocks.
 */

function getBlockOrder(state, rootClientId) {
  return state.blocks.order[rootClientId || ''] || EMPTY_ARRAY;
}
/**
 * Returns the index at which the block corresponding to the specified client
 * ID occurs within the block order, or `-1` if the block does not exist.
 *
 * @param {Object}  state        Editor state.
 * @param {string}  clientId     Block client ID.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {number} Index at which block exists in order.
 */

function getBlockIndex(state, clientId, rootClientId) {
  return getBlockOrder(state, rootClientId).indexOf(clientId);
}
/**
 * Returns true if the block corresponding to the specified client ID is
 * currently selected and no multi-selection exists, or false otherwise.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether block is selected and multi-selection exists.
 */

function isBlockSelected(state, clientId) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;

  if (selectionStart.clientId !== selectionEnd.clientId) {
    return false;
  }

  return selectionStart.clientId === clientId;
}
/**
 * Returns true if one of the block's inner blocks is selected.
 *
 * @param {Object}  state    Editor state.
 * @param {string}  clientId Block client ID.
 * @param {boolean} deep     Perform a deep check.
 *
 * @return {boolean} Whether the block as an inner block selected
 */

function hasSelectedInnerBlock(state, clientId, deep = false) {
  return Object(lodash__WEBPACK_IMPORTED_MODULE_1__["some"])(getBlockOrder(state, clientId), innerClientId => isBlockSelected(state, innerClientId) || isBlockMultiSelected(state, innerClientId) || deep && hasSelectedInnerBlock(state, innerClientId, deep));
}
/**
 * Returns true if the block corresponding to the specified client ID is
 * currently selected but isn't the last of the selected blocks. Here "last"
 * refers to the block sequence in the document, _not_ the sequence of
 * multi-selection, which is why `state.selectionEnd` isn't used.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {boolean} Whether block is selected and not the last in the
 *                   selection.
 */

function isBlockWithinSelection(state, clientId) {
  if (!clientId) {
    return false;
  }

  const clientIds = getMultiSelectedBlockClientIds(state);
  const index = clientIds.indexOf(clientId);
  return index > -1 && index < clientIds.length - 1;
}
/**
 * Returns true if a multi-selection has been made, or false otherwise.
 *
 * @param {Object} state Editor state.
 *
 * @return {boolean} Whether multi-selection has been made.
 */

function hasMultiSelection(state) {
  const {
    selectionStart,
    selectionEnd
  } = state.selection;
  return selectionStart.clientId !== selectionEnd.clientId;
}
/**
 * Whether in the process of multi-selecting or not. This flag is only true
 * while the multi-selection is being selected (by mouse move), and is false
 * once the multi-selection has been settled.
 *
 * @see hasMultiSelection
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} True if multi-selecting, false if not.
 */

function isMultiSelecting(state) {
  return state.isMultiSelecting;
}
/**
 * Selector that returns if multi-selection is enabled or not.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} True if it should be possible to multi-select blocks, false if multi-selection is disabled.
 */

function isSelectionEnabled(state) {
  return state.isSelectionEnabled;
}
/**
 * Returns the block's editing mode, defaulting to "visual" if not explicitly
 * assigned.
 *
 * @param {Object} state    Editor state.
 * @param {string} clientId Block client ID.
 *
 * @return {Object} Block editing mode.
 */

function getBlockMode(state, clientId) {
  return state.blocksMode[clientId] || 'visual';
}
/**
 * Returns true if the user is typing, or false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether user is typing.
 */

function isTyping(state) {
  return state.isTyping;
}
/**
 * Returns true if the user is dragging blocks, or false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether user is dragging blocks.
 */

function isDraggingBlocks(state) {
  return !!state.draggedBlocks.length;
}
/**
 * Returns the client ids of any blocks being directly dragged.
 *
 * This does not include children of a parent being dragged.
 *
 * @param {Object} state Global application state.
 *
 * @return {string[]} Array of dragged block client ids.
 */

function getDraggedBlockClientIds(state) {
  return state.draggedBlocks;
}
/**
 * Returns whether the block is being dragged.
 *
 * Only returns true if the block is being directly dragged,
 * not if the block is a child of a parent being dragged.
 * See `isAncestorBeingDragged` for child blocks.
 *
 * @param {Object} state    Global application state.
 * @param {string} clientId Client id for block to check.
 *
 * @return {boolean} Whether the block is being dragged.
 */

function isBlockBeingDragged(state, clientId) {
  return state.draggedBlocks.includes(clientId);
}
/**
 * Returns whether a parent/ancestor of the block is being dragged.
 *
 * @param {Object} state    Global application state.
 * @param {string} clientId Client id for block to check.
 *
 * @return {boolean} Whether the block's ancestor is being dragged.
 */

function isAncestorBeingDragged(state, clientId) {
  // Return early if no blocks are being dragged rather than
  // the more expensive check for parents.
  if (!isDraggingBlocks(state)) {
    return false;
  }

  const parents = getBlockParents(state, clientId);
  return Object(lodash__WEBPACK_IMPORTED_MODULE_1__["some"])(parents, parentClientId => isBlockBeingDragged(state, parentClientId));
}
/**
 * Returns true if the caret is within formatted text, or false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether the caret is within formatted text.
 */

function isCaretWithinFormattedText(state) {
  return state.isCaretWithinFormattedText;
}
/**
 * Returns the insertion point, the index at which the new inserted block would
 * be placed. Defaults to the last index.
 *
 * @param {Object} state Editor state.
 *
 * @return {Object} Insertion point object with `rootClientId`, `index`.
 */

function getBlockInsertionPoint(state) {
  let rootClientId, index;
  const {
    insertionPoint,
    selection: {
      selectionEnd
    }
  } = state;

  if (insertionPoint !== null) {
    return insertionPoint;
  }

  const {
    clientId
  } = selectionEnd;

  if (clientId) {
    rootClientId = getBlockRootClientId(state, clientId) || undefined;
    index = getBlockIndex(state, selectionEnd.clientId, rootClientId) + 1;
  } else {
    index = getBlockOrder(state).length;
  }

  return {
    rootClientId,
    index
  };
}
/**
 * Returns true if we should show the block insertion point.
 *
 * @param {Object} state Global application state.
 *
 * @return {?boolean} Whether the insertion point is visible or not.
 */

function isBlockInsertionPointVisible(state) {
  return state.insertionPoint !== null;
}
/**
 * Returns whether the blocks matches the template or not.
 *
 * @param {boolean} state
 * @return {?boolean} Whether the template is valid or not.
 */

function isValidTemplate(state) {
  return state.template.isValid;
}
/**
 * Returns the defined block template
 *
 * @param {boolean} state
 * @return {?Array}        Block Template
 */

function getTemplate(state) {
  return state.settings.template;
}
/**
 * Returns the defined block template lock. Optionally accepts a root block
 * client ID as context, otherwise defaulting to the global context.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional block root client ID.
 *
 * @return {?string} Block Template Lock
 */

function getTemplateLock(state, rootClientId) {
  if (!rootClientId) {
    return state.settings.templateLock;
  }

  const blockListSettings = getBlockListSettings(state, rootClientId);

  if (!blockListSettings) {
    return null;
  }

  return blockListSettings.templateLock;
}

const checkAllowList = (list, item, defaultResult = null) => {
  if (Object(lodash__WEBPACK_IMPORTED_MODULE_1__["isBoolean"])(list)) {
    return list;
  }

  if (Object(lodash__WEBPACK_IMPORTED_MODULE_1__["isArray"])(list)) {
    // TODO: when there is a canonical way to detect that we are editing a post
    // the following check should be changed to something like:
    // if ( list.includes( 'core/post-content' ) && getEditorMode() === 'post-content' && item === null )
    if (list.includes('core/post-content') && item === null) {
      return true;
    }

    return list.includes(item);
  }

  return defaultResult;
};
/**
 * Determines if the given block type is allowed to be inserted into the block list.
 * This function is not exported and not memoized because using a memoized selector
 * inside another memoized selector is just a waste of time.
 *
 * @param {Object}         state        Editor state.
 * @param {string|Object}  blockName    The block type object, e.g., the response
 *                                      from the block directory; or a string name of
 *                                      an installed block type, e.g.' core/paragraph'.
 * @param {?string}        rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given block type is allowed to be inserted.
 */


const canInsertBlockTypeUnmemoized = (state, blockName, rootClientId = null) => {
  let blockType;

  if (blockName && 'object' === typeof blockName) {
    blockType = blockName;
    blockName = blockType.name;
  } else {
    blockType = Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_3__["getBlockType"])(blockName);
  }

  if (!blockType) {
    return false;
  }

  const {
    allowedBlockTypes
  } = getSettings(state);
  const isBlockAllowedInEditor = checkAllowList(allowedBlockTypes, blockName, true);

  if (!isBlockAllowedInEditor) {
    return false;
  }

  const isLocked = !!getTemplateLock(state, rootClientId);

  if (isLocked) {
    return false;
  }

  const parentBlockListSettings = getBlockListSettings(state, rootClientId); // The parent block doesn't have settings indicating it doesn't support
  // inner blocks, return false.

  if (rootClientId && parentBlockListSettings === undefined) {
    return false;
  }

  const parentAllowedBlocks = parentBlockListSettings === null || parentBlockListSettings === void 0 ? void 0 : parentBlockListSettings.allowedBlocks;
  const hasParentAllowedBlock = checkAllowList(parentAllowedBlocks, blockName);
  const blockAllowedParentBlocks = blockType.parent;
  const parentName = getBlockName(state, rootClientId);
  const hasBlockAllowedParent = checkAllowList(blockAllowedParentBlocks, parentName);

  if (hasParentAllowedBlock !== null && hasBlockAllowedParent !== null) {
    return hasParentAllowedBlock || hasBlockAllowedParent;
  } else if (hasParentAllowedBlock !== null) {
    return hasParentAllowedBlock;
  } else if (hasBlockAllowedParent !== null) {
    return hasBlockAllowedParent;
  }

  return true;
};
/**
 * Determines if the given block type is allowed to be inserted into the block list.
 *
 * @param {Object}  state        Editor state.
 * @param {string}  blockName    The name of the block type, e.g.' core/paragraph'.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given block type is allowed to be inserted.
 */


const canInsertBlockType = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])(canInsertBlockTypeUnmemoized, (state, blockName, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.byClientId[rootClientId], state.settings.allowedBlockTypes, state.settings.templateLock]);
/**
 * Determines if the given blocks are allowed to be inserted into the block
 * list.
 *
 * @param {Object}  state        Editor state.
 * @param {string}  clientIds    The block client IDs to be inserted.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given blocks are allowed to be inserted.
 */

function canInsertBlocks(state, clientIds, rootClientId = null) {
  return clientIds.every(id => canInsertBlockType(state, getBlockName(state, id), rootClientId));
}
/**
 * Returns information about how recently and frequently a block has been inserted.
 *
 * @param {Object} state Global application state.
 * @param {string} id    A string which identifies the insert, e.g. 'core/block/12'
 *
 * @return {?{ time: number, count: number }} An object containing `time` which is when the last
 *                                            insert occurred as a UNIX epoch, and `count` which is
 *                                            the number of inserts that have occurred.
 */

function getInsertUsage(state, id) {
  var _state$preferences$in, _state$preferences$in2;

  return (_state$preferences$in = (_state$preferences$in2 = state.preferences.insertUsage) === null || _state$preferences$in2 === void 0 ? void 0 : _state$preferences$in2[id]) !== null && _state$preferences$in !== void 0 ? _state$preferences$in : null;
}
/**
 * Returns whether we can show a block type in the inserter
 *
 * @param {Object} state Global State
 * @param {Object} blockType BlockType
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Whether the given block type is allowed to be shown in the inserter.
 */


const canIncludeBlockTypeInInserter = (state, blockType, rootClientId) => {
  if (!Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_3__["hasBlockSupport"])(blockType, 'inserter', true)) {
    return false;
  }

  return canInsertBlockTypeUnmemoized(state, blockType.name, rootClientId);
};
/**
 * Return a function to be used to tranform a block variation to an inserter item
 *
 * @param {Object} state Global State
 * @param {Object} item Denormalized inserter item
 * @return {Function} Function to transform a block variation to inserter item
 */


const getItemFromVariation = (state, item) => variation => {
  const variationId = `${item.id}/${variation.name}`;
  const {
    time,
    count = 0
  } = getInsertUsage(state, variationId) || {};
  return { ...item,
    id: variationId,
    icon: variation.icon || item.icon,
    title: variation.title || item.title,
    description: variation.description || item.description,
    category: variation.category || item.category,
    // If `example` is explicitly undefined for the variation, the preview will not be shown.
    example: variation.hasOwnProperty('example') ? variation.example : item.example,
    initialAttributes: { ...item.initialAttributes,
      ...variation.attributes
    },
    innerBlocks: variation.innerBlocks,
    keywords: variation.keywords || item.keywords,
    frecency: calculateFrecency(time, count)
  };
};
/**
 * Returns the calculated frecency.
 *
 * 'frecency' is a heuristic (https://en.wikipedia.org/wiki/Frecency)
 * that combines block usage frequenty and recency.
 *
 * @param {number} time When the last insert occurred as a UNIX epoch
 * @param {number} count The number of inserts that have occurred.
 *
 * @return {number} The calculated frecency.
 */


const calculateFrecency = (time, count) => {
  if (!time) {
    return count;
  } // The selector is cached, which means Date.now() is the last time that the
  // relevant state changed. This suits our needs.


  const duration = Date.now() - time;

  switch (true) {
    case duration < MILLISECONDS_PER_HOUR:
      return count * 4;

    case duration < MILLISECONDS_PER_DAY:
      return count * 2;

    case duration < MILLISECONDS_PER_WEEK:
      return count / 2;

    default:
      return count / 4;
  }
};
/**
 * Returns a function that accepts a block type and builds an item to be shown
 * in a specific context. It's used for building items for Inserter and available
 * block Transfroms list.
 *
 * @param {Object} state Editor state.
 * @param {Object} options Options object for handling the building of a block type.
 * @param {string} options.buildScope The scope for which the item is going to be used.
 * @return {Function} Function returns an item to be shown in a specific context (Inserter|Transforms list).
 */


const buildBlockTypeItem = (state, {
  buildScope = 'inserter'
}) => blockType => {
  const id = blockType.name;
  let isDisabled = false;

  if (!Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_3__["hasBlockSupport"])(blockType.name, 'multiple', true)) {
    isDisabled = Object(lodash__WEBPACK_IMPORTED_MODULE_1__["some"])(getBlocksByClientId(state, getClientIdsWithDescendants(state)), {
      name: blockType.name
    });
  }

  const {
    time,
    count = 0
  } = getInsertUsage(state, id) || {};
  const blockItemBase = {
    id,
    name: blockType.name,
    title: blockType.title,
    icon: blockType.icon,
    isDisabled,
    frecency: calculateFrecency(time, count)
  };
  if (buildScope === 'transform') return blockItemBase;
  const inserterVariations = blockType.variations.filter(({
    scope
  }) => !scope || scope.includes('inserter'));
  return { ...blockItemBase,
    initialAttributes: {},
    description: blockType.description,
    category: blockType.category,
    keywords: blockType.keywords,
    variations: inserterVariations,
    example: blockType.example,
    utility: 1 // deprecated

  };
};
/**
 * Determines the items that appear in the inserter. Includes both static
 * items (e.g. a regular block type) and dynamic items (e.g. a reusable block).
 *
 * Each item object contains what's necessary to display a button in the
 * inserter and handle its selection.
 *
 * The 'frecency' property is a heuristic (https://en.wikipedia.org/wiki/Frecency)
 * that combines block usage frequenty and recency.
 *
 * Items are returned ordered descendingly by their 'utility' and 'frecency'.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {WPEditorInserterItem[]} Items that appear in inserter.
 *
 * @typedef {Object} WPEditorInserterItem
 * @property {string}   id                Unique identifier for the item.
 * @property {string}   name              The type of block to create.
 * @property {Object}   initialAttributes Attributes to pass to the newly created block.
 * @property {string}   title             Title of the item, as it appears in the inserter.
 * @property {string}   icon              Dashicon for the item, as it appears in the inserter.
 * @property {string}   category          Block category that the item is associated with.
 * @property {string[]} keywords          Keywords that can be searched to find this item.
 * @property {boolean}  isDisabled        Whether or not the user should be prevented from inserting
 *                                        this item.
 * @property {number}   frecency          Heuristic that combines frequency and recency.
 */


const getInserterItems = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])((state, rootClientId = null) => {
  const buildBlockTypeInserterItem = buildBlockTypeItem(state, {
    buildScope: 'inserter'
  });

  const buildReusableBlockInserterItem = reusableBlock => {
    const id = `core/block/${reusableBlock.id}`;

    const referencedBlocks = __experimentalGetParsedReusableBlock(state, reusableBlock.id);

    let referencedBlockType;

    if (referencedBlocks.length === 1) {
      referencedBlockType = Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_3__["getBlockType"])(referencedBlocks[0].name);
    }

    const {
      time,
      count = 0
    } = getInsertUsage(state, id) || {};
    const frecency = calculateFrecency(time, count);
    return {
      id,
      name: 'core/block',
      initialAttributes: {
        ref: reusableBlock.id
      },
      title: reusableBlock.title.raw,
      icon: referencedBlockType ? referencedBlockType.icon : templateIcon,
      category: 'reusable',
      keywords: [],
      isDisabled: false,
      utility: 1,
      // deprecated
      frecency
    };
  };

  const blockTypeInserterItems = Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_3__["getBlockTypes"])().filter(blockType => canIncludeBlockTypeInInserter(state, blockType, rootClientId)).map(buildBlockTypeInserterItem);
  const reusableBlockInserterItems = canInsertBlockTypeUnmemoized(state, 'core/block', rootClientId) ? getReusableBlocks(state).map(buildReusableBlockInserterItem) : []; // Exclude any block type item that is to be replaced by a default
  // variation.

  const visibleBlockTypeInserterItems = blockTypeInserterItems.filter(({
    variations = []
  }) => !variations.some(({
    isDefault
  }) => isDefault));
  const blockVariations = []; // Show all available blocks with variations

  for (const item of blockTypeInserterItems) {
    const {
      variations = []
    } = item;

    if (variations.length) {
      const variationMapper = getItemFromVariation(state, item);
      blockVariations.push(...variations.map(variationMapper));
    }
  } // Prioritize core blocks's display in inserter.


  const prioritizeCoreBlocks = (a, b) => {
    const coreBlockNamePrefix = 'core/';
    const firstIsCoreBlock = a.name.startsWith(coreBlockNamePrefix);
    const secondIsCoreBlock = b.name.startsWith(coreBlockNamePrefix);

    if (firstIsCoreBlock && secondIsCoreBlock) {
      return 0;
    }

    return firstIsCoreBlock && !secondIsCoreBlock ? -1 : 1;
  }; // Ensure core blocks are prioritized in the returned results,
  // because third party blocks can be registered earlier than
  // the core blocks (usually by using the `init` action),
  // thus affecting the display order.
  // We don't sort reusable blocks as they are handled differently.


  const sortedBlockTypes = [...visibleBlockTypeInserterItems, ...blockVariations].sort(prioritizeCoreBlocks);
  return [...sortedBlockTypes, ...reusableBlockInserterItems];
}, (state, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.byClientId, state.blocks.order, state.preferences.insertUsage, state.settings.allowedBlockTypes, state.settings.templateLock, getReusableBlocks(state), Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_3__["getBlockTypes"])()]);
/**
 * Determines the items that appear in the available block transforms list.
 *
 * Each item object contains what's necessary to display a menu item in the
 * transform list and handle its selection.
 *
 * The 'frecency' property is a heuristic (https://en.wikipedia.org/wiki/Frecency)
 * that combines block usage frequenty and recency.
 *
 * Items are returned ordered descendingly by their 'frecency'.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {WPEditorTransformItem[]} Items that appear in inserter.
 *
 * @typedef {Object} WPEditorTransformItem
 * @property {string}   id                Unique identifier for the item.
 * @property {string}   name              The type of block to create.
 * @property {string}   title             Title of the item, as it appears in the inserter.
 * @property {string}   icon              Dashicon for the item, as it appears in the inserter.
 * @property {boolean}  isDisabled        Whether or not the user should be prevented from inserting
 *                                        this item.
 * @property {number}   frecency          Heuristic that combines frequency and recency.
 */

const getBlockTransformItems = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])((state, blocks, rootClientId = null) => {
  const buildBlockTypeTransformItem = buildBlockTypeItem(state, {
    buildScope: 'transform'
  });
  const blockTypeTransformItems = Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_3__["getBlockTypes"])().filter(blockType => canIncludeBlockTypeInInserter(state, blockType, rootClientId)).map(buildBlockTypeTransformItem);
  const itemsByName = Object(lodash__WEBPACK_IMPORTED_MODULE_1__["mapKeys"])(blockTypeTransformItems, ({
    name
  }) => name);
  const possibleTransforms = Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_3__["getPossibleBlockTransformations"])(blocks).reduce((accumulator, block) => {
    if (itemsByName[block === null || block === void 0 ? void 0 : block.name]) {
      accumulator.push(itemsByName[block.name]);
    }

    return accumulator;
  }, []);
  const possibleBlockTransformations = Object(lodash__WEBPACK_IMPORTED_MODULE_1__["orderBy"])(possibleTransforms, block => itemsByName[block.name].frecency, 'desc');
  return possibleBlockTransformations;
}, (state, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.byClientId, state.preferences.insertUsage, state.settings.allowedBlockTypes, state.settings.templateLock, Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_3__["getBlockTypes"])()]);
/**
 * Determines whether there are items to show in the inserter.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {boolean} Items that appear in inserter.
 */

const hasInserterItems = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])((state, rootClientId = null) => {
  const hasBlockType = Object(lodash__WEBPACK_IMPORTED_MODULE_1__["some"])(Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_3__["getBlockTypes"])(), blockType => canIncludeBlockTypeInInserter(state, blockType, rootClientId));

  if (hasBlockType) {
    return true;
  }

  const hasReusableBlock = canInsertBlockTypeUnmemoized(state, 'core/block', rootClientId) && getReusableBlocks(state).length > 0;
  return hasReusableBlock;
}, (state, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.byClientId, state.settings.allowedBlockTypes, state.settings.templateLock, getReusableBlocks(state), Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_3__["getBlockTypes"])()]);
/**
 * Returns the list of allowed inserter blocks for inner blocks children
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Array?} The list of allowed block types.
 */

const __experimentalGetAllowedBlocks = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])((state, rootClientId = null) => {
  if (!rootClientId) {
    return;
  }

  return Object(lodash__WEBPACK_IMPORTED_MODULE_1__["filter"])(Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_3__["getBlockTypes"])(), blockType => canIncludeBlockTypeInInserter(state, blockType, rootClientId));
}, (state, rootClientId) => [state.blockListSettings[rootClientId], state.blocks.byClientId, state.settings.allowedBlockTypes, state.settings.templateLock, Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_3__["getBlockTypes"])()]);

const checkAllowListRecursive = (blocks, allowedBlockTypes) => {
  if (Object(lodash__WEBPACK_IMPORTED_MODULE_1__["isBoolean"])(allowedBlockTypes)) {
    return allowedBlockTypes;
  }

  const blocksQueue = [...blocks];

  while (blocksQueue.length > 0) {
    var _block$innerBlocks;

    const block = blocksQueue.shift();
    const isAllowed = checkAllowList(allowedBlockTypes, block.name || block.blockName, true);

    if (!isAllowed) {
      return false;
    }

    (_block$innerBlocks = block.innerBlocks) === null || _block$innerBlocks === void 0 ? void 0 : _block$innerBlocks.forEach(innerBlock => {
      blocksQueue.push(innerBlock);
    });
  }

  return true;
};

const __experimentalGetParsedPattern = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])((state, patternName) => {
  const patterns = state.settings.__experimentalBlockPatterns;
  const pattern = patterns.find(({
    name
  }) => name === patternName);

  if (!pattern) {
    return null;
  }

  return { ...pattern,
    blocks: Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_3__["parse"])(pattern.content)
  };
}, state => [state.settings.__experimentalBlockPatterns]);
const getAllAllowedPatterns = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])(state => {
  const patterns = state.settings.__experimentalBlockPatterns;
  const {
    allowedBlockTypes
  } = getSettings(state);
  const parsedPatterns = patterns.map(({
    name
  }) => __experimentalGetParsedPattern(state, name));
  const allowedPatterns = parsedPatterns.filter(({
    blocks
  }) => checkAllowListRecursive(blocks, allowedBlockTypes));
  return allowedPatterns;
}, state => [state.settings.__experimentalBlockPatterns, state.settings.allowedBlockTypes]);
/**
 * Returns the list of allowed patterns for inner blocks children.
 *
 * @param {Object}  state        Editor state.
 * @param {?string} rootClientId Optional target root client ID.
 *
 * @return {Array?} The list of allowed patterns.
 */

const __experimentalGetAllowedPatterns = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])((state, rootClientId = null) => {
  const availableParsedPatterns = getAllAllowedPatterns(state);
  const patternsAllowed = Object(lodash__WEBPACK_IMPORTED_MODULE_1__["filter"])(availableParsedPatterns, ({
    blocks
  }) => blocks.every(({
    name
  }) => canInsertBlockType(state, name, rootClientId)));
  return patternsAllowed;
}, (state, rootClientId) => [state.settings.__experimentalBlockPatterns, state.settings.allowedBlockTypes, state.settings.templateLock, state.blockListSettings[rootClientId], state.blocks.byClientId[rootClientId]]);
/**
 * Returns the list of patterns based on their declared `blockTypes`
 * and a block's name.
 * Patterns can use `blockTypes` to integrate in work flows like
 * suggesting appropriate patterns in a Placeholder state(during insertion)
 * or blocks transformations.
 *
 * @param {Object} state Editor state.
 * @param {string|string[]} blockNames Block's name or array of block names to find matching pattens.
 * @param {?string} rootClientId Optional target root client ID.
 *
 * @return {Array} The list of matched block patterns based on declared `blockTypes` and block name.
 */

const __experimentalGetPatternsByBlockTypes = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])((state, blockNames, rootClientId = null) => {
  if (!blockNames) return EMPTY_ARRAY;

  const patterns = __experimentalGetAllowedPatterns(state, rootClientId);

  const normalizedBlockNames = Array.isArray(blockNames) ? blockNames : [blockNames];
  return patterns.filter(pattern => {
    var _pattern$blockTypes, _pattern$blockTypes$s;

    return pattern === null || pattern === void 0 ? void 0 : (_pattern$blockTypes = pattern.blockTypes) === null || _pattern$blockTypes === void 0 ? void 0 : (_pattern$blockTypes$s = _pattern$blockTypes.some) === null || _pattern$blockTypes$s === void 0 ? void 0 : _pattern$blockTypes$s.call(_pattern$blockTypes, blockName => normalizedBlockNames.includes(blockName));
  });
}, (state, rootClientId) => [...__experimentalGetAllowedPatterns.getDependants(state, rootClientId)]);
/**
 * Determines the items that appear in the available pattern transforms list.
 *
 * For now we only handle blocks without InnerBlocks and take into account
 * the `__experimentalRole` property of blocks' attributes for the transformation.
 *
 * We return the first set of possible eligible block patterns,
 * by checking the `blockTypes` property. We still have to recurse through
 * block pattern's blocks and try to find matches from the selected blocks.
 * Now this happens in the consumer to avoid heavy operations in the selector.
 *
 * @param {Object}  state Editor state.
 * @param {Object[]} blocks The selected blocks.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {WPBlockPattern[]} Items that are eligible for a pattern transformation.
 */

const __experimentalGetPatternTransformItems = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])((state, blocks, rootClientId = null) => {
  if (!blocks) return EMPTY_ARRAY;
  /**
   * For now we only handle blocks without InnerBlocks and take into account
   * the `__experimentalRole` property of blocks' attributes for the transformation.
   * Note that the blocks have been retrieved through `getBlock`, which doesn't
   * return the inner blocks of an inner block controller, so we still need
   * to check for this case too.
   */

  if (blocks.some(({
    clientId,
    innerBlocks
  }) => innerBlocks.length || areInnerBlocksControlled(state, clientId))) {
    return EMPTY_ARRAY;
  } // Create a Set of the selected block names that is used in patterns filtering.


  const selectedBlockNames = Array.from(new Set(blocks.map(({
    name
  }) => name)));
  /**
   * Here we will return first set of possible eligible block patterns,
   * by checking the `blockTypes` property. We still have to recurse through
   * block pattern's blocks and try to find matches from the selected blocks.
   * Now this happens in the consumer to avoid heavy operations in the selector.
   */

  return __experimentalGetPatternsByBlockTypes(state, selectedBlockNames, rootClientId);
}, (state, rootClientId) => [...__experimentalGetPatternsByBlockTypes.getDependants(state, rootClientId)]);
/**
 * Returns the Block List settings of a block, if any exist.
 *
 * @param {Object}  state    Editor state.
 * @param {?string} clientId Block client ID.
 *
 * @return {?Object} Block settings of the block if set.
 */

function getBlockListSettings(state, clientId) {
  return state.blockListSettings[clientId];
}
/**
 * Returns the editor settings.
 *
 * @param {Object} state Editor state.
 *
 * @return {Object} The editor settings object.
 */

function getSettings(state) {
  return state.settings;
}
/**
 * Returns true if the most recent block change is be considered persistent, or
 * false otherwise. A persistent change is one committed by BlockEditorProvider
 * via its `onChange` callback, in addition to `onInput`.
 *
 * @param {Object} state Block editor state.
 *
 * @return {boolean} Whether the most recent block change was persistent.
 */

function isLastBlockChangePersistent(state) {
  return state.blocks.isPersistentChange;
}
/**
 * Returns the block list settings for an array of blocks, if any exist.
 *
 * @param {Object} state     Editor state.
 * @param {Array}  clientIds Block client IDs.
 *
 * @return {Object} An object where the keys are client ids and the values are
 *                  a block list setting object.
 */

const __experimentalGetBlockListSettingsForBlocks = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])((state, clientIds = []) => {
  return clientIds.reduce((blockListSettingsForBlocks, clientId) => {
    if (!state.blockListSettings[clientId]) {
      return blockListSettingsForBlocks;
    }

    return { ...blockListSettingsForBlocks,
      [clientId]: state.blockListSettings[clientId]
    };
  }, {});
}, state => [state.blockListSettings]);
/**
 * Returns the parsed block saved as shared block with the given ID.
 *
 * @param {Object}        state Global application state.
 * @param {number|string} ref   The shared block's ID.
 *
 * @return {Object} The parsed block.
 */

const __experimentalGetParsedReusableBlock = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])((state, ref) => {
  const reusableBlock = Object(lodash__WEBPACK_IMPORTED_MODULE_1__["find"])(getReusableBlocks(state), block => block.id === ref);

  if (!reusableBlock) {
    return null;
  } // Only reusableBlock.content.raw should be used here, `reusableBlock.content` is a
  // workaround until #22127 is fixed.


  return Object(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_3__["parse"])(typeof reusableBlock.content.raw === 'string' ? reusableBlock.content.raw : reusableBlock.content);
}, state => [getReusableBlocks(state)]);
/**
 * Returns the title of a given reusable block
 *
 * @param {Object}        state Global application state.
 * @param {number|string} ref   The shared block's ID.
 *
 * @return {string} The reusable block saved title.
 */

const __experimentalGetReusableBlockTitle = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])((state, ref) => {
  var _reusableBlock$title;

  const reusableBlock = Object(lodash__WEBPACK_IMPORTED_MODULE_1__["find"])(getReusableBlocks(state), block => block.id === ref);

  if (!reusableBlock) {
    return null;
  }

  return (_reusableBlock$title = reusableBlock.title) === null || _reusableBlock$title === void 0 ? void 0 : _reusableBlock$title.raw;
}, state => [getReusableBlocks(state)]);
/**
 * Returns true if the most recent block change is be considered ignored, or
 * false otherwise. An ignored change is one not to be committed by
 * BlockEditorProvider, neither via `onChange` nor `onInput`.
 *
 * @param {Object} state Block editor state.
 *
 * @return {boolean} Whether the most recent block change was ignored.
 */

function __unstableIsLastBlockChangeIgnored(state) {
  // TODO: Removal Plan: Changes incurred by RECEIVE_BLOCKS should not be
  // ignored if in-fact they result in a change in blocks state. The current
  // need to ignore changes not a result of user interaction should be
  // accounted for in the refactoring of reusable blocks as occurring within
  // their own separate block editor / state (#7119).
  return state.blocks.isIgnoredChange;
}
/**
 * Returns the block attributes changed as a result of the last dispatched
 * action.
 *
 * @param {Object} state Block editor state.
 *
 * @return {Object<string,Object>} Subsets of block attributes changed, keyed
 *                                 by block client ID.
 */

function __experimentalGetLastBlockAttributeChanges(state) {
  return state.lastBlockAttributesChange;
}
/**
 * Returns the available reusable blocks
 *
 * @param {Object} state Global application state.
 *
 * @return {Array} Reusable blocks
 */

function getReusableBlocks(state) {
  var _state$settings$__exp, _state$settings;

  return (_state$settings$__exp = state === null || state === void 0 ? void 0 : (_state$settings = state.settings) === null || _state$settings === void 0 ? void 0 : _state$settings.__experimentalReusableBlocks) !== null && _state$settings$__exp !== void 0 ? _state$settings$__exp : EMPTY_ARRAY;
}
/**
 * Returns whether the navigation mode is enabled.
 *
 * @param {Object} state Editor state.
 *
 * @return {boolean}     Is navigation mode enabled.
 */


function isNavigationMode(state) {
  return state.isNavigationMode;
}
/**
 * Returns whether block moving mode is enabled.
 *
 * @param {Object} state Editor state.
 *
 * @return {string}     Client Id of moving block.
 */

function hasBlockMovingClientId(state) {
  return state.hasBlockMovingClientId;
}
/**
 * Returns true if the last change was an automatic change, false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether the last change was automatic.
 */

function didAutomaticChange(state) {
  return !!state.automaticChangeStatus;
}
/**
 * Returns true if the current highlighted block matches the block clientId.
 *
 * @param {Object} state Global application state.
 * @param {string} clientId The block to check.
 *
 * @return {boolean} Whether the block is currently highlighted.
 */

function isBlockHighlighted(state, clientId) {
  return state.highlightedBlock === clientId;
}
/**
 * Checks if a given block has controlled inner blocks.
 *
 * @param {Object} state Global application state.
 * @param {string} clientId The block to check.
 *
 * @return {boolean} True if the block has controlled inner blocks.
 */

function areInnerBlocksControlled(state, clientId) {
  return !!state.blocks.controlledInnerBlocks[clientId];
}
/**
 * Returns the clientId for the first 'active' block of a given array of block names.
 * A block is 'active' if it (or a child) is the selected block.
 * Returns the first match moving up the DOM from the selected block.
 *
 * @param {Object} state Global application state.
 * @param {string[]} validBlocksNames The names of block types to check for.
 *
 * @return {string} The matching block's clientId.
 */

const __experimentalGetActiveBlockIdByBlockNames = Object(rememo__WEBPACK_IMPORTED_MODULE_2__["default"])((state, validBlockNames) => {
  if (!validBlockNames.length) {
    return null;
  } // Check if selected block is a valid entity area.


  const selectedBlockClientId = getSelectedBlockClientId(state);

  if (validBlockNames.includes(getBlockName(state, selectedBlockClientId))) {
    return selectedBlockClientId;
  } // Check if first selected block is a child of a valid entity area.


  const multiSelectedBlockClientIds = getMultiSelectedBlockClientIds(state);
  const entityAreaParents = getBlockParentsByBlockName(state, selectedBlockClientId || multiSelectedBlockClientIds[0], validBlockNames);

  if (entityAreaParents) {
    // Last parent closest/most interior.
    return Object(lodash__WEBPACK_IMPORTED_MODULE_1__["last"])(entityAreaParents);
  }

  return null;
}, (state, validBlockNames) => [state.selection.selectionStart.clientId, state.selection.selectionEnd.clientId, validBlockNames]);
/**
 * Tells if the block with the passed clientId was just inserted.
 *
 * @param {Object} state Global application state.
 * @param {Object} clientId Client Id of the block.
 * @param {?string} source Optional insertion source of the block.
 * @return {boolean} True if the block matches the last block inserted from the specified source.
 */

function wasBlockJustInserted(state, clientId, source) {
  const {
    lastBlockInserted
  } = state;
  return lastBlockInserted.clientId === clientId && lastBlockInserted.source === source;
}
//# sourceMappingURL=selectors.js.map

/***/ }),

/***/ "ly0k":
/*!************************************************************************************************!*\
  !*** ../node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/parse.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* eslint-disable @wordpress/no-unused-vars-before-return */
// Adapted from https://github.com/reworkcss/css
// because we needed to remove source map support.
// http://www.w3.org/TR/CSS21/grammar.htm
// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027
const commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
/* harmony default export */ __webpack_exports__["default"] = (function (css, options) {
  options = options || {};
  /**
   * Positional.
   */

  let lineno = 1;
  let column = 1;
  /**
   * Update lineno and column based on `str`.
   */

  function updatePosition(str) {
    const lines = str.match(/\n/g);

    if (lines) {
      lineno += lines.length;
    }

    const i = str.lastIndexOf('\n'); // eslint-disable-next-line no-bitwise

    column = ~i ? str.length - i : column + str.length;
  }
  /**
   * Mark position and patch `node.position`.
   */


  function position() {
    const start = {
      line: lineno,
      column
    };
    return function (node) {
      node.position = new Position(start);
      whitespace();
      return node;
    };
  }
  /**
   * Store position information for a node
   */


  function Position(start) {
    this.start = start;
    this.end = {
      line: lineno,
      column
    };
    this.source = options.source;
  }
  /**
   * Non-enumerable source string
   */


  Position.prototype.content = css;
  /**
   * Error `msg`.
   */

  const errorsList = [];

  function error(msg) {
    const err = new Error(options.source + ':' + lineno + ':' + column + ': ' + msg);
    err.reason = msg;
    err.filename = options.source;
    err.line = lineno;
    err.column = column;
    err.source = css;

    if (options.silent) {
      errorsList.push(err);
    } else {
      throw err;
    }
  }
  /**
   * Parse stylesheet.
   */


  function stylesheet() {
    const rulesList = rules();
    return {
      type: 'stylesheet',
      stylesheet: {
        source: options.source,
        rules: rulesList,
        parsingErrors: errorsList
      }
    };
  }
  /**
   * Opening brace.
   */


  function open() {
    return match(/^{\s*/);
  }
  /**
   * Closing brace.
   */


  function close() {
    return match(/^}/);
  }
  /**
   * Parse ruleset.
   */


  function rules() {
    let node;
    const accumulator = [];
    whitespace();
    comments(accumulator);

    while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {
      if (node !== false) {
        accumulator.push(node);
        comments(accumulator);
      }
    }

    return accumulator;
  }
  /**
   * Match `re` and return captures.
   */


  function match(re) {
    const m = re.exec(css);

    if (!m) {
      return;
    }

    const str = m[0];
    updatePosition(str);
    css = css.slice(str.length);
    return m;
  }
  /**
   * Parse whitespace.
   */


  function whitespace() {
    match(/^\s*/);
  }
  /**
   * Parse comments;
   */


  function comments(accumulator) {
    let c;
    accumulator = accumulator || []; // eslint-disable-next-line no-cond-assign

    while (c = comment()) {
      if (c !== false) {
        accumulator.push(c);
      }
    }

    return accumulator;
  }
  /**
   * Parse comment.
   */


  function comment() {
    const pos = position();

    if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) {
      return;
    }

    let i = 2;

    while ('' !== css.charAt(i) && ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))) {
      ++i;
    }

    i += 2;

    if ('' === css.charAt(i - 1)) {
      return error('End of comment missing');
    }

    const str = css.slice(2, i - 2);
    column += 2;
    updatePosition(str);
    css = css.slice(i);
    column += 2;
    return pos({
      type: 'comment',
      comment: str
    });
  }
  /**
   * Parse selector.
   */


  function selector() {
    const m = match(/^([^{]+)/);

    if (!m) {
      return;
    } // FIXME: Remove all comments from selectors http://ostermiller.org/findcomment.html


    return trim(m[0]).replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, '').replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, function (matched) {
      return matched.replace(/,/g, '\u200C');
    }).split(/\s*(?![^(]*\)),\s*/).map(function (s) {
      return s.replace(/\u200C/g, ',');
    });
  }
  /**
   * Parse declaration.
   */


  function declaration() {
    const pos = position(); // prop

    let prop = match(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);

    if (!prop) {
      return;
    }

    prop = trim(prop[0]); // :

    if (!match(/^:\s*/)) {
      return error("property missing ':'");
    } // val


    const val = match(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/);
    const ret = pos({
      type: 'declaration',
      property: prop.replace(commentre, ''),
      value: val ? trim(val[0]).replace(commentre, '') : ''
    }); // ;

    match(/^[;\s]*/);
    return ret;
  }
  /**
   * Parse declarations.
   */


  function declarations() {
    const decls = [];

    if (!open()) {
      return error("missing '{'");
    }

    comments(decls); // declarations

    let decl; // eslint-disable-next-line no-cond-assign

    while (decl = declaration()) {
      if (decl !== false) {
        decls.push(decl);
        comments(decls);
      }
    }

    if (!close()) {
      return error("missing '}'");
    }

    return decls;
  }
  /**
   * Parse keyframe.
   */


  function keyframe() {
    let m;
    const vals = [];
    const pos = position(); // eslint-disable-next-line no-cond-assign

    while (m = match(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/)) {
      vals.push(m[1]);
      match(/^,\s*/);
    }

    if (!vals.length) {
      return;
    }

    return pos({
      type: 'keyframe',
      values: vals,
      declarations: declarations()
    });
  }
  /**
   * Parse keyframes.
   */


  function atkeyframes() {
    const pos = position();
    let m = match(/^@([-\w]+)?keyframes\s*/);

    if (!m) {
      return;
    }

    const vendor = m[1]; // identifier

    m = match(/^([-\w]+)\s*/);

    if (!m) {
      return error('@keyframes missing name');
    }

    const name = m[1];

    if (!open()) {
      return error("@keyframes missing '{'");
    }

    let frame;
    let frames = comments(); // eslint-disable-next-line no-cond-assign

    while (frame = keyframe()) {
      frames.push(frame);
      frames = frames.concat(comments());
    }

    if (!close()) {
      return error("@keyframes missing '}'");
    }

    return pos({
      type: 'keyframes',
      name,
      vendor,
      keyframes: frames
    });
  }
  /**
   * Parse supports.
   */


  function atsupports() {
    const pos = position();
    const m = match(/^@supports *([^{]+)/);

    if (!m) {
      return;
    }

    const supports = trim(m[1]);

    if (!open()) {
      return error("@supports missing '{'");
    }

    const style = comments().concat(rules());

    if (!close()) {
      return error("@supports missing '}'");
    }

    return pos({
      type: 'supports',
      supports,
      rules: style
    });
  }
  /**
   * Parse host.
   */


  function athost() {
    const pos = position();
    const m = match(/^@host\s*/);

    if (!m) {
      return;
    }

    if (!open()) {
      return error("@host missing '{'");
    }

    const style = comments().concat(rules());

    if (!close()) {
      return error("@host missing '}'");
    }

    return pos({
      type: 'host',
      rules: style
    });
  }
  /**
   * Parse media.
   */


  function atmedia() {
    const pos = position();
    const m = match(/^@media *([^{]+)/);

    if (!m) {
      return;
    }

    const media = trim(m[1]);

    if (!open()) {
      return error("@media missing '{'");
    }

    const style = comments().concat(rules());

    if (!close()) {
      return error("@media missing '}'");
    }

    return pos({
      type: 'media',
      media,
      rules: style
    });
  }
  /**
   * Parse custom-media.
   */


  function atcustommedia() {
    const pos = position();
    const m = match(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);

    if (!m) {
      return;
    }

    return pos({
      type: 'custom-media',
      name: trim(m[1]),
      media: trim(m[2])
    });
  }
  /**
   * Parse paged media.
   */


  function atpage() {
    const pos = position();
    const m = match(/^@page */);

    if (!m) {
      return;
    }

    const sel = selector() || [];

    if (!open()) {
      return error("@page missing '{'");
    }

    let decls = comments(); // declarations

    let decl; // eslint-disable-next-line no-cond-assign

    while (decl = declaration()) {
      decls.push(decl);
      decls = decls.concat(comments());
    }

    if (!close()) {
      return error("@page missing '}'");
    }

    return pos({
      type: 'page',
      selectors: sel,
      declarations: decls
    });
  }
  /**
   * Parse document.
   */


  function atdocument() {
    const pos = position();
    const m = match(/^@([-\w]+)?document *([^{]+)/);

    if (!m) {
      return;
    }

    const vendor = trim(m[1]);
    const doc = trim(m[2]);

    if (!open()) {
      return error("@document missing '{'");
    }

    const style = comments().concat(rules());

    if (!close()) {
      return error("@document missing '}'");
    }

    return pos({
      type: 'document',
      document: doc,
      vendor,
      rules: style
    });
  }
  /**
   * Parse font-face.
   */


  function atfontface() {
    const pos = position();
    const m = match(/^@font-face\s*/);

    if (!m) {
      return;
    }

    if (!open()) {
      return error("@font-face missing '{'");
    }

    let decls = comments(); // declarations

    let decl; // eslint-disable-next-line no-cond-assign

    while (decl = declaration()) {
      decls.push(decl);
      decls = decls.concat(comments());
    }

    if (!close()) {
      return error("@font-face missing '}'");
    }

    return pos({
      type: 'font-face',
      declarations: decls
    });
  }
  /**
   * Parse import
   */


  const atimport = _compileAtrule('import');
  /**
   * Parse charset
   */


  const atcharset = _compileAtrule('charset');
  /**
   * Parse namespace
   */


  const atnamespace = _compileAtrule('namespace');
  /**
   * Parse non-block at-rules
   */


  function _compileAtrule(name) {
    const re = new RegExp('^@' + name + '\\s*([^;]+);');
    return function () {
      const pos = position();
      const m = match(re);

      if (!m) {
        return;
      }

      const ret = {
        type: name
      };
      ret[name] = m[1].trim();
      return pos(ret);
    };
  }
  /**
   * Parse at rule.
   */


  function atrule() {
    if (css[0] !== '@') {
      return;
    }

    return atkeyframes() || atmedia() || atcustommedia() || atsupports() || atimport() || atcharset() || atnamespace() || atdocument() || atpage() || athost() || atfontface();
  }
  /**
   * Parse rule.
   */


  function rule() {
    const pos = position();
    const sel = selector();

    if (!sel) {
      return error('selector missing');
    }

    comments();
    return pos({
      type: 'rule',
      selectors: sel,
      declarations: declarations()
    });
  }

  return addParent(stylesheet());
});
/**
 * Trim `str`.
 */

function trim(str) {
  return str ? str.replace(/^\s+|\s+$/g, '') : '';
}
/**
 * Adds non-enumerable parent node reference to each node.
 */


function addParent(obj, parent) {
  const isNode = obj && typeof obj.type === 'string';
  const childParent = isNode ? obj : parent;

  for (const k in obj) {
    const value = obj[k];

    if (Array.isArray(value)) {
      value.forEach(function (v) {
        addParent(v, childParent);
      });
    } else if (value && typeof value === 'object') {
      addParent(value, childParent);
    }
  }

  if (isNode) {
    Object.defineProperty(obj, 'parent', {
      configurable: true,
      writable: true,
      enumerable: false,
      value: parent || null
    });
  }

  return obj;
}
/* eslint-enable @wordpress/no-unused-vars-before-return */
//# sourceMappingURL=parse.js.map

/***/ }),

/***/ "oeJU":
/*!******************************************************************************************!*\
  !*** ../node_modules/@wordpress/block-editor/build-module/utils/get-paste-event-data.js ***!
  \******************************************************************************************/
/*! exports provided: getPasteEventData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPasteEventData", function() { return getPasteEventData; });
/* harmony import */ var _wordpress_blob__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wordpress/blob */ "Gi3w");
/* harmony import */ var _wordpress_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wordpress/dom */ "DSWK");
/**
 * WordPress dependencies
 */


function getPasteEventData({
  clipboardData
}) {
  let plainText = '';
  let html = ''; // IE11 only supports `Text` as an argument for `getData` and will
  // otherwise throw an invalid argument error, so we try the standard
  // arguments first, then fallback to `Text` if they fail.

  try {
    plainText = clipboardData.getData('text/plain');
    html = clipboardData.getData('text/html');
  } catch (error1) {
    try {
      html = clipboardData.getData('Text');
    } catch (error2) {
      // Some browsers like UC Browser paste plain text by default and
      // don't support clipboardData at all, so allow default
      // behaviour.
      return;
    }
  }

  const files = Object(_wordpress_dom__WEBPACK_IMPORTED_MODULE_1__["getFilesFromDataTransfer"])(clipboardData).filter(({
    type
  }) => /^image\/(?:jpe?g|png|gif)$/.test(type)); // Only process files if no HTML is present.
  // A pasted file may have the URL as plain text.

  if (files.length && !html) {
    html = files.map(file => `<img src="${Object(_wordpress_blob__WEBPACK_IMPORTED_MODULE_0__["createBlobURL"])(file)}">`).join('');
    plainText = '';
  }

  return {
    html,
    plainText
  };
}
//# sourceMappingURL=get-paste-event-data.js.map

/***/ }),

/***/ "rsyr":
/*!***************************************************************************!*\
  !*** ../node_modules/@wordpress/block-editor/build-module/store/index.js ***!
  \***************************************************************************/
/*! exports provided: storeConfig, store */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "storeConfig", function() { return storeConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "store", function() { return store; });
/* harmony import */ var _wordpress_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wordpress/data */ "OgwO");
/* harmony import */ var _reducer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reducer */ "DdeO");
/* harmony import */ var _selectors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selectors */ "l0ML");
/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./actions */ "FfR3");
/* harmony import */ var _controls__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./controls */ "VGZE");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants */ "Gg2m");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */






/**
 * Block editor data store configuration.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#registerStore
 *
 * @type {Object}
 */

const storeConfig = {
  reducer: _reducer__WEBPACK_IMPORTED_MODULE_1__["default"],
  selectors: _selectors__WEBPACK_IMPORTED_MODULE_2__,
  actions: _actions__WEBPACK_IMPORTED_MODULE_3__,
  controls: _controls__WEBPACK_IMPORTED_MODULE_4__["default"]
};
/**
 * Store definition for the block editor namespace.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#createReduxStore
 *
 * @type {Object}
 */

const store = Object(_wordpress_data__WEBPACK_IMPORTED_MODULE_0__["createReduxStore"])(_constants__WEBPACK_IMPORTED_MODULE_5__["STORE_NAME"], { ...storeConfig,
  persist: ['preferences']
}); // Ideally we'd use register instead of register stores.

Object(_wordpress_data__WEBPACK_IMPORTED_MODULE_0__["registerStore"])(_constants__WEBPACK_IMPORTED_MODULE_5__["STORE_NAME"], { ...storeConfig,
  persist: ['preferences']
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "sWxo":
/*!***************************************************************************!*\
  !*** ../node_modules/@wordpress/block-editor/build-module/store/array.js ***!
  \***************************************************************************/
/*! exports provided: insertAt, moveTo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertAt", function() { return insertAt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "moveTo", function() { return moveTo; });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "9va6");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/**
 * External dependencies
 */

/**
 * Insert one or multiple elements into a given position of an array.
 *
 * @param {Array}  array    Source array.
 * @param {*}      elements Elements to insert.
 * @param {number} index    Insert Position.
 *
 * @return {Array}          Result.
 */

function insertAt(array, elements, index) {
  return [...array.slice(0, index), ...Object(lodash__WEBPACK_IMPORTED_MODULE_0__["castArray"])(elements), ...array.slice(index)];
}
/**
 * Moves an element in an array.
 *
 * @param {Array}  array Source array.
 * @param {number} from  Source index.
 * @param {number} to    Destination index.
 * @param {number} count Number of elements to move.
 *
 * @return {Array}       Result.
 */

function moveTo(array, from, to, count = 1) {
  const withoutMovedElements = [...array];
  withoutMovedElements.splice(from, count);
  return insertAt(withoutMovedElements, array.slice(from, from + count), to);
}
//# sourceMappingURL=array.js.map

/***/ }),

/***/ "saH8":
/*!************************************************************************************************!*\
  !*** ../node_modules/@wordpress/block-editor/build-module/utils/transform-styles/ast/index.js ***!
  \************************************************************************************************/
/*! exports provided: parse, stringify */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _parse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse */ "ly0k");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return _parse__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _stringify__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify */ "fpEj");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stringify", function() { return _stringify__WEBPACK_IMPORTED_MODULE_1__["default"]; });

// Adapted from https://github.com/reworkcss/css
// because we needed to remove source map support.


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "whF7":
/*!*****************************************************************************************!*\
  !*** ../node_modules/@wordpress/block-editor/node_modules/inherits/inherits_browser.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "x28A":
/*!************************************************************************************************!*\
  !*** ../node_modules/@wordpress/block-editor/build-module/utils/block-variation-transforms.js ***!
  \************************************************************************************************/
/*! exports provided: __experimentalGetMatchingVariation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__experimentalGetMatchingVariation", function() { return __experimentalGetMatchingVariation; });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "9va6");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/**
 * External dependencies
 */

/** @typedef {import('@wordpress/blocks').WPBlockVariation} WPBlockVariation */

/**
 * Matches the provided block variations with a block's attributes. If no match
 * or more than one matches are found it returns `undefined`. If a single match is
 * found it returns it.
 *
 * This is a simple implementation for now as it takes into account only the attributes
 * of a block variation and not `InnerBlocks`.
 *
 * @param {Object} blockAttributes - The block attributes to try to find a match.
 * @param {WPBlockVariation[]} variations - A list of block variations to test for a match.
 * @return {?WPBlockVariation} - If a match is found returns it. If not or more than one matches are found returns `undefined`.
 */

const __experimentalGetMatchingVariation = (blockAttributes, variations) => {
  if (!variations || !blockAttributes) return;
  const matches = variations.filter(({
    attributes
  }) => {
    if (!attributes || !Object.keys(attributes).length) return false;
    return Object(lodash__WEBPACK_IMPORTED_MODULE_0__["isMatch"])(blockAttributes, attributes);
  });
  if (matches.length !== 1) return;
  return matches[0];
};
//# sourceMappingURL=block-variation-transforms.js.map

/***/ })

}]);
//# sourceMappingURL=vendor~.._node_modules_@wordpress_block-editor_b.js.map