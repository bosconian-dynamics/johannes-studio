{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport { useCallback, useDispatch, useEffect, useMemo, useSelect, useState } from \"/lib/data\";\nexport const importScenes = async (...names) => Promise.all(names.map(async name => {\n  console.log(\"MAP\", name);\n  const {\n    default: Scene\n  } = await import(`./scenes/${name}/index.jsx`);\n  if (!Scene.displayName) Scene.displayName = name;\n  return Scene;\n}));\nexport const useActiveScene = (scenes, {\n  store,\n  path,\n  initial\n}) => {\n  _s();\n\n  const {\n    setActiveSceneName\n  } = useDispatch(\"sazerac/core\");\n  const {\n    active_scene_name\n  } = useSelect(select => {\n    var _select$getActiveScen;\n\n    return (_select$getActiveScen = select(\"sazerac/core\").getActiveSceneName()) !== null && _select$getActiveScen !== void 0 ? _select$getActiveScen : Object.keys(scenes)[0];\n  });\n  return useMemo(() => {\n    const index = Object.keys(scenes).indexOf(active_scene_name);\n\n    const setActiveScene = scene_name_index => {\n      let name;\n\n      switch (typeof scene_name_index) {\n        case \"number\":\n          name = scenes[Object.keys(scenes)[scene_name_index]].name;\n          break;\n\n        case \"string\":\n          name = scene_name_index;\n          break;\n\n        case \"object\":\n          name = scene_name_index.name;\n          break;\n\n        default:\n          throw new TypeError(\"Unkown scene resolvable.\");\n      }\n\n      setActiveSceneName(name);\n    };\n\n    return {\n      name: active_scene_name,\n      index,\n      scene: scenes[active_scene_name],\n      setActiveScene,\n      set: setActiveScene\n    };\n  }, [scenes, active_scene_name, setActiveSceneName]);\n};\n\n_s(useActiveScene, \"v9JDmkcSMm2fV1q+EqFSX5tjR2w=\", false, function () {\n  return [useDispatch, useSelect];\n});\n\nexport const useScenes = (...scenes_or_names) => {\n  _s2();\n\n  const [scenes, setScenes] = useState({});\n  const setScene = useCallback((name, scene) => {\n    if (!name) name = scene.displayName;\n    setScenes({ ...scenes,\n      [name]: scene\n    });\n    return scene;\n  }, [scenes]);\n  const loadScene = useCallback(async scene_or_name => {\n    let scene = Object.entries(scenes).find(([name, scene]) => [name, scene, scene.displayName].includes(scene_or_name));\n    if (scene) return scene;\n\n    if (\"string\" === typeof scene_or_name) {\n      try {\n        [scene] = await importScenes(scene_or_name);\n        return setScene(scene, scene_or_name);\n      } catch (err) {\n        console.error(`No such scene: \"${scene_or_name}\" :: ${err}`);\n        return;\n      }\n    }\n\n    return setScene(scene);\n  }, [setScene, scenes]);\n  useEffect(() => {\n    for (const scene_or_name of scenes_or_names) {\n      loadScene(scene_or_name);\n    }\n  }, [scenes_or_names, loadScene]);\n  return {\n    scenes,\n    set: setScene\n  };\n};\n\n_s2(useScenes, \"HzntiadJZCWysKdvW+J0YfkYsEg=\");","map":{"version":3,"sources":["/sandbox/src/lib/scenes/index.js"],"names":["useCallback","useDispatch","useEffect","useMemo","useSelect","useState","importScenes","names","Promise","all","map","name","console","log","default","Scene","displayName","useActiveScene","scenes","store","path","initial","setActiveSceneName","active_scene_name","select","getActiveSceneName","Object","keys","index","indexOf","setActiveScene","scene_name_index","TypeError","scene","set","useScenes","scenes_or_names","setScenes","setScene","loadScene","scene_or_name","entries","find","includes","err","error"],"mappings":"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","sourcesContent":["import {\r\n  useCallback,\r\n  useDispatch,\r\n  useEffect,\r\n  useMemo,\r\n  useSelect,\r\n  useState\r\n} from \"/lib/data\";\r\n\r\nexport const importScenes = async (...names) =>\r\n  Promise.all(\r\n    names.map(async (name) => {\r\n      console.log(\"MAP\", name);\r\n      const { default: Scene } = await import(`./scenes/${name}/index.jsx`);\r\n\r\n      if (!Scene.displayName) Scene.displayName = name;\r\n\r\n      return Scene;\r\n    })\r\n  );\r\n\r\nexport const useActiveScene = (scenes, { store, path, initial }) => {\r\n  const { setActiveSceneName } = useDispatch(\"sazerac/core\");\r\n  const { active_scene_name } = useSelect(\r\n    (select) =>\r\n      select(\"sazerac/core\").getActiveSceneName() ?? Object.keys(scenes)[0]\r\n  );\r\n\r\n  return useMemo(() => {\r\n    const index = Object.keys(scenes).indexOf(active_scene_name);\r\n    const setActiveScene = (scene_name_index) => {\r\n      let name;\r\n\r\n      switch (typeof scene_name_index) {\r\n        case \"number\":\r\n          name = scenes[Object.keys(scenes)[scene_name_index]].name;\r\n          break;\r\n        case \"string\":\r\n          name = scene_name_index;\r\n          break;\r\n        case \"object\":\r\n          name = scene_name_index.name;\r\n          break;\r\n        default:\r\n          throw new TypeError(\"Unkown scene resolvable.\");\r\n      }\r\n\r\n      setActiveSceneName(name);\r\n    };\r\n\r\n    return {\r\n      name: active_scene_name,\r\n      index,\r\n      scene: scenes[active_scene_name],\r\n      setActiveScene,\r\n      set: setActiveScene\r\n    };\r\n  }, [scenes, active_scene_name, setActiveSceneName]);\r\n};\r\n\r\nexport const useScenes = (...scenes_or_names) => {\r\n  const [scenes, setScenes] = useState({});\r\n\r\n  const setScene = useCallback(\r\n    (name, scene) => {\r\n      if (!name) name = scene.displayName;\r\n\r\n      setScenes({ ...scenes, [name]: scene });\r\n\r\n      return scene;\r\n    },\r\n    [scenes]\r\n  );\r\n\r\n  const loadScene = useCallback(\r\n    async (scene_or_name) => {\r\n      let scene = Object.entries(scenes).find(([name, scene]) =>\r\n        [name, scene, scene.displayName].includes(scene_or_name)\r\n      );\r\n\r\n      if (scene) return scene;\r\n\r\n      if (\"string\" === typeof scene_or_name) {\r\n        try {\r\n          [scene] = await importScenes(scene_or_name);\r\n\r\n          return setScene(scene, scene_or_name);\r\n        } catch (err) {\r\n          console.error(`No such scene: \"${scene_or_name}\" :: ${err}`);\r\n          return;\r\n        }\r\n      }\r\n\r\n      return setScene(scene);\r\n    },\r\n    [setScene, scenes]\r\n  );\r\n\r\n  useEffect(() => {\r\n    for (const scene_or_name of scenes_or_names) {\r\n      loadScene(scene_or_name);\r\n    }\r\n  }, [scenes_or_names, loadScene]);\r\n\r\n  return {\r\n    scenes,\r\n    set: setScene\r\n  };\r\n};\r\n"]},"metadata":{},"sourceType":"module"}