{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { createElement } from \"@wordpress/element\";\nimport { useEffect, useState } from \"@wordpress/element\";\nimport \"./style.scss\";\n\nconst loadScenes = async (...names) => Promise.all(names.map(name => import(`/scenes/${name}`)));\n\nexport const useScenes = (...scenes_or_names) => {\n  _s();\n\n  const [scenes, setScenes] = useState({});\n  useEffect(() => {\n    (async () => {\n      for (const scene_or_name of scenes_or_names) {\n        getScene(scene_or_name);\n      }\n    })();\n  }, [scenes_or_names]);\n\n  const getScene = async scene_or_name => {\n    let scene = Object.entries(scenes).find(([name, scene]) => [name, scene, scene.displayName].includes(scene_or_name));\n    if (scene) return scene;\n\n    if (\"string\" === typeof scene_or_name) {\n      try {\n        const [scene] = await loadScenes(scene_or_name);\n        return setScene(scene, scene_or_name);\n      } catch (err) {\n        console.error(`No such scene: \"${scene_or_name}\" :: ${err}`);\n        return;\n      }\n    }\n\n    return setScene(scene);\n  };\n\n  const setScene = (scene, name) => {\n    if (!name) name = scene.displayName;\n    setScenes({\n      [name]: scene\n    });\n    return scene;\n  };\n\n  return {\n    scenes,\n    getScene,\n    get: getScene,\n    setScene,\n    set: setScene\n  };\n};\n\n_s(useScenes, \"3Cg0qwfb22N5e8zLZUxPGOHWRVs=\");\n\nexport function App() {\n  //const { scenes } = useScenes(\"BlockEditor\");\n  const scenes = {};\n  return createElement(\"div\", {\n    className: \"app\"\n  }, createElement(\"header\", null, createElement(\"h2\", null, \"Berlin Editor\")), Object.values(scenes));\n}\n_c = App;\nexport default App;\n/* export default () => (\r\n  <div className=\"app\">\r\n    <h1>{process.env.SANDBOX_URL}</h1>\r\n  </div>\r\n); */\n\nvar _c;\n\n$RefreshReg$(_c, \"App\");","map":{"version":3,"sources":["/sandbox/src/App.jsx"],"names":["useEffect","useState","loadScenes","names","Promise","all","map","name","useScenes","scenes_or_names","scenes","setScenes","scene_or_name","getScene","scene","Object","entries","find","displayName","includes","setScene","err","console","error","get","set","App","values"],"mappings":";;;AAAA,SAASA,SAAT,EAAoBC,QAApB,QAAoC,oBAApC;AAEA,OAAO,cAAP;;AAEA,MAAMC,UAAU,GAAG,OAAO,GAAGC,KAAV,KACjBC,OAAO,CAACC,GAAR,CAAYF,KAAK,CAACG,GAAN,CAAWC,IAAD,IAAU,OAAQ,WAAUA,IAAK,EAAvB,CAApB,CAAZ,CADF;;AAGA,OAAO,MAAMC,SAAS,GAAG,CAAC,GAAGC,eAAJ,KAAwB;AAAA;;AAC/C,QAAM,CAACC,MAAD,EAASC,SAAT,IAAsBV,QAAQ,CAAC,EAAD,CAApC;AAEAD,EAAAA,SAAS,CAAC,MAAM;AACd,KAAC,YAAY;AACX,WAAK,MAAMY,aAAX,IAA4BH,eAA5B,EAA6C;AAC3CI,QAAAA,QAAQ,CAACD,aAAD,CAAR;AACD;AACF,KAJD;AAKD,GANQ,EAMN,CAACH,eAAD,CANM,CAAT;;AAQA,QAAMI,QAAQ,GAAG,MAAOD,aAAP,IAAyB;AACxC,QAAIE,KAAK,GAAGC,MAAM,CAACC,OAAP,CAAeN,MAAf,EAAuBO,IAAvB,CAA4B,CAAC,CAACV,IAAD,EAAOO,KAAP,CAAD,KACtC,CAACP,IAAD,EAAOO,KAAP,EAAcA,KAAK,CAACI,WAApB,EAAiCC,QAAjC,CAA0CP,aAA1C,CADU,CAAZ;AAIA,QAAIE,KAAJ,EAAW,OAAOA,KAAP;;AAEX,QAAI,aAAa,OAAOF,aAAxB,EAAuC;AACrC,UAAI;AACF,cAAM,CAACE,KAAD,IAAU,MAAMZ,UAAU,CAACU,aAAD,CAAhC;AAEA,eAAOQ,QAAQ,CAACN,KAAD,EAAQF,aAAR,CAAf;AACD,OAJD,CAIE,OAAOS,GAAP,EAAY;AACZC,QAAAA,OAAO,CAACC,KAAR,CAAe,mBAAkBX,aAAc,QAAOS,GAAI,EAA1D;AACA;AACD;AACF;;AAED,WAAOD,QAAQ,CAACN,KAAD,CAAf;AACD,GAnBD;;AAqBA,QAAMM,QAAQ,GAAG,CAACN,KAAD,EAAQP,IAAR,KAAiB;AAChC,QAAI,CAACA,IAAL,EAAWA,IAAI,GAAGO,KAAK,CAACI,WAAb;AAEXP,IAAAA,SAAS,CAAC;AAAE,OAACJ,IAAD,GAAQO;AAAV,KAAD,CAAT;AAEA,WAAOA,KAAP;AACD,GAND;;AAQA,SAAO;AACLJ,IAAAA,MADK;AAELG,IAAAA,QAFK;AAGLW,IAAAA,GAAG,EAAEX,QAHA;AAILO,IAAAA,QAJK;AAKLK,IAAAA,GAAG,EAAEL;AALA,GAAP;AAOD,CA/CM;;GAAMZ,S;;AAiDb,OAAO,SAASkB,GAAT,GAAe;AACpB;AACA,QAAMhB,MAAM,GAAG,EAAf;AAEA,SACE;AAAK,IAAA,SAAS,EAAC;AAAf,KACE,8BACE,0CADF,CADF,EAIGK,MAAM,CAACY,MAAP,CAAcjB,MAAd,CAJH,CADF;AAQD;KAZegB,G;AAchB,eAAeA,GAAf;AAEA;AACA;AACA;AACA;AACA","sourcesContent":["import { useEffect, useState } from \"@wordpress/element\";\r\n\r\nimport \"./style.scss\";\r\n\r\nconst loadScenes = async (...names) =>\r\n  Promise.all(names.map((name) => import(`/scenes/${name}`)));\r\n\r\nexport const useScenes = (...scenes_or_names) => {\r\n  const [scenes, setScenes] = useState({});\r\n\r\n  useEffect(() => {\r\n    (async () => {\r\n      for (const scene_or_name of scenes_or_names) {\r\n        getScene(scene_or_name);\r\n      }\r\n    })();\r\n  }, [scenes_or_names]);\r\n\r\n  const getScene = async (scene_or_name) => {\r\n    let scene = Object.entries(scenes).find(([name, scene]) =>\r\n      [name, scene, scene.displayName].includes(scene_or_name)\r\n    );\r\n\r\n    if (scene) return scene;\r\n\r\n    if (\"string\" === typeof scene_or_name) {\r\n      try {\r\n        const [scene] = await loadScenes(scene_or_name);\r\n\r\n        return setScene(scene, scene_or_name);\r\n      } catch (err) {\r\n        console.error(`No such scene: \"${scene_or_name}\" :: ${err}`);\r\n        return;\r\n      }\r\n    }\r\n\r\n    return setScene(scene);\r\n  };\r\n\r\n  const setScene = (scene, name) => {\r\n    if (!name) name = scene.displayName;\r\n\r\n    setScenes({ [name]: scene });\r\n\r\n    return scene;\r\n  };\r\n\r\n  return {\r\n    scenes,\r\n    getScene,\r\n    get: getScene,\r\n    setScene,\r\n    set: setScene\r\n  };\r\n};\r\n\r\nexport function App() {\r\n  //const { scenes } = useScenes(\"BlockEditor\");\r\n  const scenes = {};\r\n\r\n  return (\r\n    <div className=\"app\">\r\n      <header>\r\n        <h2>Berlin Editor</h2>\r\n      </header>\r\n      {Object.values(scenes)}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n\r\n/* export default () => (\r\n  <div className=\"app\">\r\n    <h1>{process.env.SANDBOX_URL}</h1>\r\n  </div>\r\n); */\r\n"]},"metadata":{},"sourceType":"module"}