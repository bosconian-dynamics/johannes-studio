{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport { useCallback, useDispatch, useEffect, useMemo, useSelect, useState } from \"/lib/data\";\nexport const importScenes = async (...names) => Promise.all(names.map(async name => {\n  console.log(\"MAP\", name);\n  const {\n    default: Scene\n  } = await import(`./scenes/${name}/index.jsx`);\n  if (!Scene.displayName) Scene.displayName = name;\n  return Scene;\n}));\nexport const useActiveScene = (scenes, {\n  selector,\n  action,\n  initial\n}) => {\n  _s();\n\n  const {\n    setActiveSceneName\n  } = useDispatch();\n  const {\n    active_scene_name\n  } = useSelect(select => (selector !== null && selector !== void 0 ? selector : select(\"sazerac/core\").getActiveSceneName)());\n  const dispatchAction = action !== null && action !== void 0 ? action : setActiveSceneName;\n  return useMemo(() => {\n    const index = Object.keys(scenes).indexOf(active_scene_name);\n\n    const setActiveScene = scene_name_index => {\n      let name;\n\n      switch (typeof scene_name_index) {\n        case \"number\":\n          name = scenes[Object.keys(scenes)[scene_name_index]].name;\n          break;\n\n        case \"string\":\n          name = scene_name_index;\n          break;\n\n        case \"object\":\n          name = scene_name_index.name;\n          break;\n\n        default:\n          throw new TypeError(\"Unkown scene resolvable.\");\n      }\n\n      dispatchAction(name);\n    };\n\n    return {\n      name: active_scene_name,\n      index,\n      scene: scenes[active_scene_name],\n      setActiveScene,\n      set: setActiveScene\n    };\n  }, [scenes, active_scene_name, dispatchAction]);\n};\n\n_s(useActiveScene, \"v9JDmkcSMm2fV1q+EqFSX5tjR2w=\", false, function () {\n  return [useDispatch, useSelect];\n});\n\nexport const useScenes = (...scenes_or_names) => {\n  _s2();\n\n  const [scenes, setScenes] = useState({});\n  const setScene = useCallback((name, scene) => {\n    if (!name) name = scene.displayName;\n    setScenes({ ...scenes,\n      [name]: scene\n    });\n    return scene;\n  }, [scenes]);\n  const loadScene = useCallback(async scene_or_name => {\n    let scene = Object.entries(scenes).find(([name, scene]) => [name, scene, scene.displayName].includes(scene_or_name));\n    if (scene) return scene;\n\n    if (\"string\" === typeof scene_or_name) {\n      try {\n        [scene] = await importScenes(scene_or_name);\n        return setScene(scene, scene_or_name);\n      } catch (err) {\n        console.error(`No such scene: \"${scene_or_name}\" :: ${err}`);\n        return;\n      }\n    }\n\n    return setScene(scene);\n  }, [setScene, scenes]);\n  useEffect(() => {\n    for (const scene_or_name of scenes_or_names) {\n      loadScene(scene_or_name);\n    }\n  }, [scenes_or_names, loadScene]);\n  return {\n    scenes,\n    set: setScene\n  };\n};\n\n_s2(useScenes, \"HzntiadJZCWysKdvW+J0YfkYsEg=\");","map":{"version":3,"sources":["/sandbox/src/lib/scenes/index.js"],"names":["useCallback","useDispatch","useEffect","useMemo","useSelect","useState","importScenes","names","Promise","all","map","name","console","log","default","Scene","displayName","useActiveScene","scenes","selector","action","initial","setActiveSceneName","active_scene_name","select","getActiveSceneName","dispatchAction","index","Object","keys","indexOf","setActiveScene","scene_name_index","TypeError","scene","set","useScenes","scenes_or_names","setScenes","setScene","loadScene","scene_or_name","entries","find","includes","err","error"],"mappings":"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","sourcesContent":["import {\r\n  useCallback,\r\n  useDispatch,\r\n  useEffect,\r\n  useMemo,\r\n  useSelect,\r\n  useState\r\n} from \"/lib/data\";\r\n\r\nexport const importScenes = async (...names) =>\r\n  Promise.all(\r\n    names.map(async (name) => {\r\n      console.log(\"MAP\", name);\r\n      const { default: Scene } = await import(`./scenes/${name}/index.jsx`);\r\n\r\n      if (!Scene.displayName) Scene.displayName = name;\r\n\r\n      return Scene;\r\n    })\r\n  );\r\n\r\nexport const useActiveScene = (scenes, { selector, action, initial }) => {\r\n  const { setActiveSceneName } = useDispatch();\r\n  const { active_scene_name } = useSelect((select) =>\r\n    (selector ?? select(\"sazerac/core\").getActiveSceneName)()\r\n  );\r\n\r\n  const dispatchAction = action ?? setActiveSceneName;\r\n\r\n  return useMemo(() => {\r\n    const index = Object.keys(scenes).indexOf(active_scene_name);\r\n    const setActiveScene = (scene_name_index) => {\r\n      let name;\r\n\r\n      switch (typeof scene_name_index) {\r\n        case \"number\":\r\n          name = scenes[Object.keys(scenes)[scene_name_index]].name;\r\n          break;\r\n        case \"string\":\r\n          name = scene_name_index;\r\n          break;\r\n        case \"object\":\r\n          name = scene_name_index.name;\r\n          break;\r\n        default:\r\n          throw new TypeError(\"Unkown scene resolvable.\");\r\n      }\r\n\r\n      dispatchAction(name);\r\n    };\r\n\r\n    return {\r\n      name: active_scene_name,\r\n      index,\r\n      scene: scenes[active_scene_name],\r\n      setActiveScene,\r\n      set: setActiveScene\r\n    };\r\n  }, [scenes, active_scene_name, dispatchAction]);\r\n};\r\n\r\nexport const useScenes = (...scenes_or_names) => {\r\n  const [scenes, setScenes] = useState({});\r\n\r\n  const setScene = useCallback(\r\n    (name, scene) => {\r\n      if (!name) name = scene.displayName;\r\n\r\n      setScenes({ ...scenes, [name]: scene });\r\n\r\n      return scene;\r\n    },\r\n    [scenes]\r\n  );\r\n\r\n  const loadScene = useCallback(\r\n    async (scene_or_name) => {\r\n      let scene = Object.entries(scenes).find(([name, scene]) =>\r\n        [name, scene, scene.displayName].includes(scene_or_name)\r\n      );\r\n\r\n      if (scene) return scene;\r\n\r\n      if (\"string\" === typeof scene_or_name) {\r\n        try {\r\n          [scene] = await importScenes(scene_or_name);\r\n\r\n          return setScene(scene, scene_or_name);\r\n        } catch (err) {\r\n          console.error(`No such scene: \"${scene_or_name}\" :: ${err}`);\r\n          return;\r\n        }\r\n      }\r\n\r\n      return setScene(scene);\r\n    },\r\n    [setScene, scenes]\r\n  );\r\n\r\n  useEffect(() => {\r\n    for (const scene_or_name of scenes_or_names) {\r\n      loadScene(scene_or_name);\r\n    }\r\n  }, [scenes_or_names, loadScene]);\r\n\r\n  return {\r\n    scenes,\r\n    set: setScene\r\n  };\r\n};\r\n"]},"metadata":{},"sourceType":"module"}